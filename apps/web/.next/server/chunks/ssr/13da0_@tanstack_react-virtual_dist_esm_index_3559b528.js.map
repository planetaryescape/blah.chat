{"version":3,"sources":["../../../../../../node_modules/.bun/%40tanstack%2Bvirtual-core%403.13.13/node_modules/%40tanstack/virtual-core/src/utils.ts","../../../../../../node_modules/.bun/%40tanstack%2Bvirtual-core%403.13.13/node_modules/%40tanstack/virtual-core/src/index.ts","../../../../../../node_modules/.bun/%40tanstack%2Breact-virtual%403.13.13%2B67f6792bdf102c28/node_modules/%40tanstack/react-virtual/src/index.tsx"],"sourcesContent":["export type NoInfer<A extends any> = [A][A extends any ? 0 : never]\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\n\nexport function memo<TDeps extends ReadonlyArray<any>, TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: false | string\n    debug?: () => boolean\n    onChange?: (result: TResult) => void\n    initialDeps?: TDeps\n    skipInitialOnChange?: boolean\n  },\n) {\n  let deps = opts.initialDeps ?? []\n  let result: TResult | undefined\n  let isInitial = true\n\n  function memoizedFunction(): TResult {\n    let depTime: number\n    if (opts.key && opts.debug?.()) depTime = Date.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (!depsChanged) {\n      return result!\n    }\n\n    deps = newDeps\n\n    let resultTime: number\n    if (opts.key && opts.debug?.()) resultTime = Date.now()\n\n    result = fn(...newDeps)\n\n    if (opts.key && opts.debug?.()) {\n      const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100\n      const resultEndTime = Math.round((Date.now() - resultTime!) * 100) / 100\n      const resultFpsPercentage = resultEndTime / 16\n\n      const pad = (str: number | string, num: number) => {\n        str = String(str)\n        while (str.length < num) {\n          str = ' ' + str\n        }\n        return str\n      }\n\n      console.info(\n        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120),\n            )}deg 100% 31%);`,\n        opts?.key,\n      )\n    }\n\n    if (opts?.onChange && !(isInitial && opts.skipInitialOnChange)) {\n      opts.onChange(result)\n    }\n\n    isInitial = false\n\n    return result\n  }\n\n  // Attach updateDeps to the function itself\n  memoizedFunction.updateDeps = (newDeps: [...TDeps]) => {\n    deps = newDeps\n  }\n\n  return memoizedFunction\n}\n\nexport function notUndefined<T>(value: T | undefined, msg?: string): T {\n  if (value === undefined) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ''}`)\n  } else {\n    return value\n  }\n}\n\nexport const approxEqual = (a: number, b: number) => Math.abs(a - b) < 1.01\n\nexport const debounce = (\n  targetWindow: Window & typeof globalThis,\n  fn: Function,\n  ms: number,\n) => {\n  let timeoutId: number\n  return function (this: any, ...args: Array<any>) {\n    targetWindow.clearTimeout(timeoutId)\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms)\n  }\n}\n","import { approxEqual, debounce, memo, notUndefined } from './utils'\n\nexport * from './utils'\n\n//\n\ntype ScrollDirection = 'forward' | 'backward'\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\nexport interface ScrollToOptions {\n  align?: ScrollAlignment\n  behavior?: ScrollBehavior\n}\n\ntype ScrollToOffsetOptions = ScrollToOptions\n\ntype ScrollToIndexOptions = ScrollToOptions\n\nexport interface Range {\n  startIndex: number\n  endIndex: number\n  overscan: number\n  count: number\n}\n\ntype Key = number | string | bigint\n\nexport interface VirtualItem {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n  lane: number\n}\n\nexport interface Rect {\n  width: number\n  height: number\n}\n\n//\n\nconst getRect = (element: HTMLElement): Rect => {\n  const { offsetWidth, offsetHeight } = element\n  return { width: offsetWidth, height: offsetHeight }\n}\n\nexport const defaultKeyExtractor = (index: number) => index\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0)\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport const observeElementRect = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  const handler = (rect: Rect) => {\n    const { width, height } = rect\n    cb({ width: Math.round(width), height: Math.round(height) })\n  }\n\n  handler(getRect(element as unknown as HTMLElement))\n\n  if (!targetWindow.ResizeObserver) {\n    return () => {}\n  }\n\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0]\n      if (entry?.borderBoxSize) {\n        const box = entry.borderBoxSize[0]\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize })\n          return\n        }\n      }\n      handler(getRect(element as unknown as HTMLElement))\n    }\n\n    instance.options.useAnimationFrameWithResizeObserver\n      ? requestAnimationFrame(run)\n      : run()\n  })\n\n  observer.observe(element, { box: 'border-box' })\n\n  return () => {\n    observer.unobserve(element)\n  }\n}\n\nconst addEventListenerOptions = {\n  passive: true,\n}\n\nexport const observeWindowRect = (\n  instance: Virtualizer<Window, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight })\n  }\n  handler()\n\n  element.addEventListener('resize', handler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('resize', handler)\n  }\n}\n\nconst supportsScrollend =\n  typeof window == 'undefined' ? true : 'onscrollend' in window\n\ntype ObserveOffsetCallBack = (offset: number, isScrolling: boolean) => void\n\nexport const observeElementOffset = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: ObserveOffsetCallBack,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback =\n    instance.options.useScrollendEvent && supportsScrollend\n      ? () => undefined\n      : debounce(\n          targetWindow,\n          () => {\n            cb(offset, false)\n          },\n          instance.options.isScrollingResetDelay,\n        )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    const { horizontal, isRtl } = instance.options\n    offset = horizontal\n      ? element['scrollLeft'] * ((isRtl && -1) || 1)\n      : element['scrollTop']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  const registerScrollendEvent =\n    instance.options.useScrollendEvent && supportsScrollend\n  if (registerScrollendEvent) {\n    element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n  }\n  return () => {\n    element.removeEventListener('scroll', handler)\n    if (registerScrollendEvent) {\n      element.removeEventListener('scrollend', endHandler)\n    }\n  }\n}\n\nexport const observeWindowOffset = (\n  instance: Virtualizer<Window, any>,\n  cb: ObserveOffsetCallBack,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback =\n    instance.options.useScrollendEvent && supportsScrollend\n      ? () => undefined\n      : debounce(\n          targetWindow,\n          () => {\n            cb(offset, false)\n          },\n          instance.options.isScrollingResetDelay,\n        )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    offset = element[instance.options.horizontal ? 'scrollX' : 'scrollY']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  const registerScrollendEvent =\n    instance.options.useScrollendEvent && supportsScrollend\n  if (registerScrollendEvent) {\n    element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n  }\n  return () => {\n    element.removeEventListener('scroll', handler)\n    if (registerScrollendEvent) {\n      element.removeEventListener('scrollend', endHandler)\n    }\n  }\n}\n\nexport const measureElement = <TItemElement extends Element>(\n  element: TItemElement,\n  entry: ResizeObserverEntry | undefined,\n  instance: Virtualizer<any, TItemElement>,\n) => {\n  if (entry?.borderBoxSize) {\n    const box = entry.borderBoxSize[0]\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? 'inlineSize' : 'blockSize'],\n      )\n      return size\n    }\n  }\n\n  return (element as unknown as HTMLElement)[\n    instance.options.horizontal ? 'offsetWidth' : 'offsetHeight'\n  ]\n}\n\nexport const windowScroll = <T extends Window>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport const elementScroll = <T extends Element>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport interface VirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  // Required from the user\n  count: number\n  getScrollElement: () => TScrollElement | null\n  estimateSize: (index: number) => number\n\n  // Required from the framework adapter (but can be overridden)\n  scrollToFn: (\n    offset: number,\n    options: { adjustments?: number; behavior?: ScrollBehavior },\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => void\n  observeElementRect: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (rect: Rect) => void,\n  ) => void | (() => void)\n  observeElementOffset: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: ObserveOffsetCallBack,\n  ) => void | (() => void)\n  // Optional\n  debug?: boolean\n  initialRect?: Rect\n  onChange?: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    sync: boolean,\n  ) => void\n  measureElement?: (\n    element: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => number\n  overscan?: number\n  horizontal?: boolean\n  paddingStart?: number\n  paddingEnd?: number\n  scrollPaddingStart?: number\n  scrollPaddingEnd?: number\n  initialOffset?: number | (() => number)\n  getItemKey?: (index: number) => Key\n  rangeExtractor?: (range: Range) => Array<number>\n  scrollMargin?: number\n  gap?: number\n  indexAttribute?: string\n  initialMeasurementsCache?: Array<VirtualItem>\n  lanes?: number\n  isScrollingResetDelay?: number\n  useScrollendEvent?: boolean\n  enabled?: boolean\n  isRtl?: boolean\n  useAnimationFrameWithResizeObserver?: boolean\n}\n\nexport class Virtualizer<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  private unsubs: Array<void | (() => void)> = []\n  options!: Required<VirtualizerOptions<TScrollElement, TItemElement>>\n  scrollElement: TScrollElement | null = null\n  targetWindow: (Window & typeof globalThis) | null = null\n  isScrolling = false\n  measurementsCache: Array<VirtualItem> = []\n  private itemSizeCache = new Map<Key, number>()\n  private laneAssignments = new Map<number, number>() // index → lane cache\n  private pendingMeasuredCacheIndexes: Array<number> = []\n  private prevLanes: number | undefined = undefined\n  private lanesChangedFlag = false\n  private lanesSettling = false\n  scrollRect: Rect | null = null\n  scrollOffset: number | null = null\n  scrollDirection: ScrollDirection | null = null\n  private scrollAdjustments = 0\n  shouldAdjustScrollPositionOnItemSizeChange:\n    | undefined\n    | ((\n        item: VirtualItem,\n        delta: number,\n        instance: Virtualizer<TScrollElement, TItemElement>,\n      ) => boolean)\n  elementsCache = new Map<Key, TItemElement>()\n  private observer = (() => {\n    let _ro: ResizeObserver | null = null\n\n    const get = () => {\n      if (_ro) {\n        return _ro\n      }\n\n      if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n        return null\n      }\n\n      return (_ro = new this.targetWindow.ResizeObserver((entries) => {\n        entries.forEach((entry) => {\n          const run = () => {\n            this._measureElement(entry.target as TItemElement, entry)\n          }\n          this.options.useAnimationFrameWithResizeObserver\n            ? requestAnimationFrame(run)\n            : run()\n        })\n      }))\n    }\n\n    return {\n      disconnect: () => {\n        get()?.disconnect()\n        _ro = null\n      },\n      observe: (target: Element) =>\n        get()?.observe(target, { box: 'border-box' }),\n      unobserve: (target: Element) => get()?.unobserve(target),\n    }\n  })()\n  range: { startIndex: number; endIndex: number } | null = null\n\n  constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>) {\n    this.setOptions(opts)\n  }\n\n  setOptions = (opts: VirtualizerOptions<TScrollElement, TItemElement>) => {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: () => {},\n      measureElement,\n      initialRect: { width: 0, height: 0 },\n      scrollMargin: 0,\n      gap: 0,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: [],\n      lanes: 1,\n      isScrollingResetDelay: 150,\n      enabled: true,\n      isRtl: false,\n      useScrollendEvent: false,\n      useAnimationFrameWithResizeObserver: false,\n      ...opts,\n    }\n  }\n\n  private notify = (sync: boolean) => {\n    this.options.onChange?.(this, sync)\n  }\n\n  private maybeNotify = memo(\n    () => {\n      this.calculateRange()\n\n      return [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ]\n    },\n    (isScrolling) => {\n      this.notify(isScrolling)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'maybeNotify',\n      debug: () => this.options.debug,\n      initialDeps: [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ] as [boolean, number | null, number | null],\n    },\n  )\n\n  private cleanup = () => {\n    this.unsubs.filter(Boolean).forEach((d) => d!())\n    this.unsubs = []\n    this.observer.disconnect()\n    this.scrollElement = null\n    this.targetWindow = null\n  }\n\n  _didMount = () => {\n    return () => {\n      this.cleanup()\n    }\n  }\n\n  _willUpdate = () => {\n    const scrollElement = this.options.enabled\n      ? this.options.getScrollElement()\n      : null\n\n    if (this.scrollElement !== scrollElement) {\n      this.cleanup()\n\n      if (!scrollElement) {\n        this.maybeNotify()\n        return\n      }\n\n      this.scrollElement = scrollElement\n\n      if (this.scrollElement && 'ownerDocument' in this.scrollElement) {\n        this.targetWindow = this.scrollElement.ownerDocument.defaultView\n      } else {\n        this.targetWindow = this.scrollElement?.window ?? null\n      }\n\n      this.elementsCache.forEach((cached) => {\n        this.observer.observe(cached)\n      })\n\n      this._scrollToOffset(this.getScrollOffset(), {\n        adjustments: undefined,\n        behavior: undefined,\n      })\n\n      this.unsubs.push(\n        this.options.observeElementRect(this, (rect) => {\n          this.scrollRect = rect\n          this.maybeNotify()\n        }),\n      )\n\n      this.unsubs.push(\n        this.options.observeElementOffset(this, (offset, isScrolling) => {\n          this.scrollAdjustments = 0\n          this.scrollDirection = isScrolling\n            ? this.getScrollOffset() < offset\n              ? 'forward'\n              : 'backward'\n            : null\n          this.scrollOffset = offset\n          this.isScrolling = isScrolling\n\n          this.maybeNotify()\n        }),\n      )\n    }\n  }\n\n  private getSize = () => {\n    if (!this.options.enabled) {\n      this.scrollRect = null\n      return 0\n    }\n\n    this.scrollRect = this.scrollRect ?? this.options.initialRect\n\n    return this.scrollRect[this.options.horizontal ? 'width' : 'height']\n  }\n\n  private getScrollOffset = () => {\n    if (!this.options.enabled) {\n      this.scrollOffset = null\n      return 0\n    }\n\n    this.scrollOffset =\n      this.scrollOffset ??\n      (typeof this.options.initialOffset === 'function'\n        ? this.options.initialOffset()\n        : this.options.initialOffset)\n\n    return this.scrollOffset\n  }\n\n  private getFurthestMeasurement = (\n    measurements: Array<VirtualItem>,\n    index: number,\n  ) => {\n    const furthestMeasurementsFound = new Map<number, true>()\n    const furthestMeasurements = new Map<number, VirtualItem>()\n    for (let m = index - 1; m >= 0; m--) {\n      const measurement = measurements[m]!\n\n      if (furthestMeasurementsFound.has(measurement.lane)) {\n        continue\n      }\n\n      const previousFurthestMeasurement = furthestMeasurements.get(\n        measurement.lane,\n      )\n      if (\n        previousFurthestMeasurement == null ||\n        measurement.end > previousFurthestMeasurement.end\n      ) {\n        furthestMeasurements.set(measurement.lane, measurement)\n      } else if (measurement.end < previousFurthestMeasurement.end) {\n        furthestMeasurementsFound.set(measurement.lane, true)\n      }\n\n      if (furthestMeasurementsFound.size === this.options.lanes) {\n        break\n      }\n    }\n\n    return furthestMeasurements.size === this.options.lanes\n      ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n          if (a.end === b.end) {\n            return a.index - b.index\n          }\n\n          return a.end - b.end\n        })[0]\n      : undefined\n  }\n\n  private getMeasurementOptions = memo(\n    () => [\n      this.options.count,\n      this.options.paddingStart,\n      this.options.scrollMargin,\n      this.options.getItemKey,\n      this.options.enabled,\n      this.options.lanes,\n    ],\n    (count, paddingStart, scrollMargin, getItemKey, enabled, lanes) => {\n      const lanesChanged =\n        this.prevLanes !== undefined && this.prevLanes !== lanes\n\n      if (lanesChanged) {\n        // Set flag for getMeasurements to handle\n        this.lanesChangedFlag = true\n      }\n\n      this.prevLanes = lanes\n      this.pendingMeasuredCacheIndexes = []\n\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey,\n        enabled,\n        lanes,\n      }\n    },\n    {\n      key: false,\n      skipInitialOnChange: true,\n      onChange: () => {\n        // Notify when measurement options change as they affect total size\n        this.notify(this.isScrolling)\n      },\n    },\n  )\n\n  private getMeasurements = memo(\n    () => [this.getMeasurementOptions(), this.itemSizeCache],\n    (\n      { count, paddingStart, scrollMargin, getItemKey, enabled, lanes },\n      itemSizeCache,\n    ) => {\n      if (!enabled) {\n        this.measurementsCache = []\n        this.itemSizeCache.clear()\n        this.laneAssignments.clear()\n        return []\n      }\n\n      // Clean up stale lane cache entries when count decreases\n      if (this.laneAssignments.size > count) {\n        for (const index of this.laneAssignments.keys()) {\n          if (index >= count) {\n            this.laneAssignments.delete(index)\n          }\n        }\n      }\n\n      // ✅ Force complete recalculation when lanes change\n      if (this.lanesChangedFlag) {\n        this.lanesChangedFlag = false // Reset immediately\n        this.lanesSettling = true // Start settling period\n        this.measurementsCache = []\n        this.itemSizeCache.clear()\n        this.laneAssignments.clear() // Clear lane cache for new lane count\n        // Clear pending indexes to force min = 0\n        this.pendingMeasuredCacheIndexes = []\n      }\n\n      if (this.measurementsCache.length === 0) {\n        this.measurementsCache = this.options.initialMeasurementsCache\n        this.measurementsCache.forEach((item) => {\n          this.itemSizeCache.set(item.key, item.size)\n        })\n      }\n\n      // ✅ During lanes settling, ignore pendingMeasuredCacheIndexes to prevent repositioning\n      const min = this.lanesSettling\n        ? 0\n        : this.pendingMeasuredCacheIndexes.length > 0\n          ? Math.min(...this.pendingMeasuredCacheIndexes)\n          : 0\n      this.pendingMeasuredCacheIndexes = []\n\n      // ✅ End settling period when cache is fully built\n      if (this.lanesSettling && this.measurementsCache.length === count) {\n        this.lanesSettling = false\n      }\n\n      const measurements = this.measurementsCache.slice(0, min)\n\n      // ✅ Performance: Track last item index per lane for O(1) lookup\n      const laneLastIndex: Array<number | undefined> = new Array(lanes).fill(\n        undefined,\n      )\n\n      // Initialize from existing measurements (before min)\n      for (let m = 0; m < min; m++) {\n        const item = measurements[m]\n        if (item) {\n          laneLastIndex[item.lane] = m\n        }\n      }\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i)\n\n        // Check for cached lane assignment\n        const cachedLane = this.laneAssignments.get(i)\n        let lane: number\n        let start: number\n\n        if (cachedLane !== undefined && this.options.lanes > 1) {\n          // Use cached lane - O(1) lookup for previous item in same lane\n          lane = cachedLane\n          const prevIndex = laneLastIndex[lane]\n          const prevInLane =\n            prevIndex !== undefined ? measurements[prevIndex] : undefined\n          start = prevInLane\n            ? prevInLane.end + this.options.gap\n            : paddingStart + scrollMargin\n        } else {\n          // No cache - use original logic (find shortest lane)\n          const furthestMeasurement =\n            this.options.lanes === 1\n              ? measurements[i - 1]\n              : this.getFurthestMeasurement(measurements, i)\n\n          start = furthestMeasurement\n            ? furthestMeasurement.end + this.options.gap\n            : paddingStart + scrollMargin\n\n          lane = furthestMeasurement\n            ? furthestMeasurement.lane\n            : i % this.options.lanes\n\n          // Cache the lane assignment\n          if (this.options.lanes > 1) {\n            this.laneAssignments.set(i, lane)\n          }\n        }\n\n        const measuredSize = itemSizeCache.get(key)\n        const size =\n          typeof measuredSize === 'number'\n            ? measuredSize\n            : this.options.estimateSize(i)\n\n        const end = start + size\n\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane,\n        }\n\n        // ✅ Performance: Update lane's last item index\n        laneLastIndex[lane] = i\n      }\n\n      this.measurementsCache = measurements\n\n      return measurements\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug,\n    },\n  )\n\n  calculateRange = memo(\n    () => [\n      this.getMeasurements(),\n      this.getSize(),\n      this.getScrollOffset(),\n      this.options.lanes,\n    ],\n    (measurements, outerSize, scrollOffset, lanes) => {\n      return (this.range =\n        measurements.length > 0 && outerSize > 0\n          ? calculateRange({\n              measurements,\n              outerSize,\n              scrollOffset,\n              lanes,\n            })\n          : null)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualIndexes = memo(\n    () => {\n      let startIndex: number | null = null\n      let endIndex: number | null = null\n      const range = this.calculateRange()\n      if (range) {\n        startIndex = range.startIndex\n        endIndex = range.endIndex\n      }\n      this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex])\n      return [\n        this.options.rangeExtractor,\n        this.options.overscan,\n        this.options.count,\n        startIndex,\n        endIndex,\n      ]\n    },\n    (rangeExtractor, overscan, count, startIndex, endIndex) => {\n      return startIndex === null || endIndex === null\n        ? []\n        : rangeExtractor({\n            startIndex,\n            endIndex,\n            overscan,\n            count,\n          })\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getVirtualIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  indexFromElement = (node: TItemElement) => {\n    const attributeName = this.options.indexAttribute\n    const indexStr = node.getAttribute(attributeName)\n\n    if (!indexStr) {\n      console.warn(\n        `Missing attribute name '${attributeName}={index}' on measured element.`,\n      )\n      return -1\n    }\n\n    return parseInt(indexStr, 10)\n  }\n\n  private _measureElement = (\n    node: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n  ) => {\n    const index = this.indexFromElement(node)\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n    const key = item.key\n    const prevNode = this.elementsCache.get(key)\n\n    if (prevNode !== node) {\n      if (prevNode) {\n        this.observer.unobserve(prevNode)\n      }\n      this.observer.observe(node)\n      this.elementsCache.set(key, node)\n    }\n\n    if (node.isConnected) {\n      this.resizeItem(index, this.options.measureElement(node, entry, this))\n    }\n  }\n\n  resizeItem = (index: number, size: number) => {\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n    const itemSize = this.itemSizeCache.get(item.key) ?? item.size\n    const delta = size - itemSize\n\n    if (delta !== 0) {\n      if (\n        this.shouldAdjustScrollPositionOnItemSizeChange !== undefined\n          ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this)\n          : item.start < this.getScrollOffset() + this.scrollAdjustments\n      ) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('correction', delta)\n        }\n\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: (this.scrollAdjustments += delta),\n          behavior: undefined,\n        })\n      }\n\n      this.pendingMeasuredCacheIndexes.push(item.index)\n      this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size))\n\n      this.notify(false)\n    }\n  }\n\n  measureElement = (node: TItemElement | null | undefined) => {\n    if (!node) {\n      this.elementsCache.forEach((cached, key) => {\n        if (!cached.isConnected) {\n          this.observer.unobserve(cached)\n          this.elementsCache.delete(key)\n        }\n      })\n      return\n    }\n\n    this._measureElement(node, undefined)\n  }\n\n  getVirtualItems = memo(\n    () => [this.getVirtualIndexes(), this.getMeasurements()],\n    (indexes, measurements) => {\n      const virtualItems: Array<VirtualItem> = []\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k]!\n        const measurement = measurements[i]!\n\n        virtualItems.push(measurement)\n      }\n\n      return virtualItems\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getVirtualItems',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualItemForOffset = (offset: number) => {\n    const measurements = this.getMeasurements()\n    if (measurements.length === 0) {\n      return undefined\n    }\n    return notUndefined(\n      measurements[\n        findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index: number) => notUndefined(measurements[index]).start,\n          offset,\n        )\n      ],\n    )\n  }\n\n  getOffsetForAlignment = (\n    toOffset: number,\n    align: ScrollAlignment,\n    itemSize = 0,\n  ) => {\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      align = toOffset >= scrollOffset + size ? 'end' : 'start'\n    }\n\n    if (align === 'center') {\n      // When aligning to a particular item (e.g. with scrollToIndex),\n      // adjust offset by the size of the item to center on the item\n      toOffset += (itemSize - size) / 2\n    } else if (align === 'end') {\n      toOffset -= size\n    }\n\n    const maxOffset = this.getTotalSize() + this.options.scrollMargin - size\n\n    return Math.max(Math.min(maxOffset, toOffset), 0)\n  }\n\n  getOffsetForIndex = (index: number, align: ScrollAlignment = 'auto') => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return undefined\n    }\n\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n        align = 'end'\n      } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n        align = 'start'\n      } else {\n        return [scrollOffset, align] as const\n      }\n    }\n\n    const toOffset =\n      align === 'end'\n        ? item.end + this.options.scrollPaddingEnd\n        : item.start - this.options.scrollPaddingStart\n\n    return [\n      this.getOffsetForAlignment(toOffset, align, item.size),\n      align,\n    ] as const\n  }\n\n  private isDynamicMode = () => this.elementsCache.size > 0\n\n  scrollToOffset = (\n    toOffset: number,\n    { align = 'start', behavior }: ScrollToOffsetOptions = {},\n  ) => {\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  scrollToIndex = (\n    index: number,\n    { align: initialAlign = 'auto', behavior }: ScrollToIndexOptions = {},\n  ) => {\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    let attempts = 0\n    const maxAttempts = 10\n\n    const tryScroll = (currentAlign: ScrollAlignment) => {\n      if (!this.targetWindow) return\n\n      const offsetInfo = this.getOffsetForIndex(index, currentAlign)\n      if (!offsetInfo) {\n        console.warn('Failed to get offset for index:', index)\n        return\n      }\n      const [offset, align] = offsetInfo\n      this._scrollToOffset(offset, { adjustments: undefined, behavior })\n\n      this.targetWindow.requestAnimationFrame(() => {\n        const currentOffset = this.getScrollOffset()\n        const afterInfo = this.getOffsetForIndex(index, align)\n        if (!afterInfo) {\n          console.warn('Failed to get offset for index:', index)\n          return\n        }\n\n        if (!approxEqual(afterInfo[0], currentOffset)) {\n          scheduleRetry(align)\n        }\n      })\n    }\n\n    const scheduleRetry = (align: ScrollAlignment) => {\n      if (!this.targetWindow) return\n\n      attempts++\n      if (attempts < maxAttempts) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('Schedule retry', attempts, maxAttempts)\n        }\n        this.targetWindow.requestAnimationFrame(() => tryScroll(align))\n      } else {\n        console.warn(\n          `Failed to scroll to index ${index} after ${maxAttempts} attempts.`,\n        )\n      }\n    }\n\n    tryScroll(initialAlign)\n  }\n\n  scrollBy = (delta: number, { behavior }: ScrollToOffsetOptions = {}) => {\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getScrollOffset() + delta, {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  getTotalSize = () => {\n    const measurements = this.getMeasurements()\n\n    let end: number\n    // If there are no measurements, set the end to paddingStart\n    // If there is only one lane, use the last measurement's end\n    // Otherwise find the maximum end value among all measurements\n    if (measurements.length === 0) {\n      end = this.options.paddingStart\n    } else if (this.options.lanes === 1) {\n      end = measurements[measurements.length - 1]?.end ?? 0\n    } else {\n      const endByLane = Array<number | null>(this.options.lanes).fill(null)\n      let endIndex = measurements.length - 1\n      while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n        const item = measurements[endIndex]!\n        if (endByLane[item.lane] === null) {\n          endByLane[item.lane] = item.end\n        }\n\n        endIndex--\n      }\n\n      end = Math.max(...endByLane.filter((val): val is number => val !== null))\n    }\n\n    return Math.max(\n      end - this.options.scrollMargin + this.options.paddingEnd,\n      0,\n    )\n  }\n\n  private _scrollToOffset = (\n    offset: number,\n    {\n      adjustments,\n      behavior,\n    }: {\n      adjustments: number | undefined\n      behavior: ScrollBehavior | undefined\n    },\n  ) => {\n    this.options.scrollToFn(offset, { behavior, adjustments }, this)\n  }\n\n  measure = () => {\n    this.itemSizeCache = new Map()\n    this.laneAssignments = new Map() // Clear lane cache for full re-layout\n    this.notify(false)\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    const middle = ((low + high) / 2) | 0\n    const currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes,\n}: {\n  measurements: Array<VirtualItem>\n  outerSize: number\n  scrollOffset: number\n  lanes: number\n}) {\n  const lastIndex = measurements.length - 1\n  const getOffset = (index: number) => measurements[index]!.start\n\n  // handle case when item count is less than or equal to lanes\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex,\n    }\n  }\n\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset,\n  )\n  let endIndex = startIndex\n\n  if (lanes === 1) {\n    while (\n      endIndex < lastIndex &&\n      measurements[endIndex]!.end < scrollOffset + outerSize\n    ) {\n      endIndex++\n    }\n  } else if (lanes > 1) {\n    // Expand forward until we include the visible items from all lanes\n    // which are closer to the end of the virtualizer window\n    const endPerLane = Array(lanes).fill(0)\n    while (\n      endIndex < lastIndex &&\n      endPerLane.some((pos) => pos < scrollOffset + outerSize)\n    ) {\n      const item = measurements[endIndex]!\n      endPerLane[item.lane] = item.end\n      endIndex++\n    }\n\n    // Expand backward until we include all lanes' visible items\n    // closer to the top\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize)\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex]!\n      startPerLane[item.lane] = item.start\n      startIndex--\n    }\n\n    // Align startIndex to the beginning of its lane\n    startIndex = Math.max(0, startIndex - (startIndex % lanes))\n    // Align endIndex to the end of its lane\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - (endIndex % lanes)))\n  }\n\n  return { startIndex, endIndex }\n}\n","import * as React from 'react'\nimport { flushSync } from 'react-dom'\nimport {\n  Virtualizer,\n  elementScroll,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll,\n} from '@tanstack/virtual-core'\nimport type { PartialKeys, VirtualizerOptions } from '@tanstack/virtual-core'\n\nexport * from '@tanstack/virtual-core'\n\nconst useIsomorphicLayoutEffect =\n  typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nfunction useVirtualizerBase<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n>(\n  options: VirtualizerOptions<TScrollElement, TItemElement>,\n): Virtualizer<TScrollElement, TItemElement> {\n  const rerender = React.useReducer(() => ({}), {})[1]\n\n  const resolvedOptions: VirtualizerOptions<TScrollElement, TItemElement> = {\n    ...options,\n    onChange: (instance, sync) => {\n      if (sync) {\n        flushSync(rerender)\n      } else {\n        rerender()\n      }\n      options.onChange?.(instance, sync)\n    },\n  }\n\n  const [instance] = React.useState(\n    () => new Virtualizer<TScrollElement, TItemElement>(resolvedOptions),\n  )\n\n  instance.setOptions(resolvedOptions)\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._didMount()\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate()\n  })\n\n  return instance\n}\n\nexport function useVirtualizer<\n  TScrollElement extends Element,\n  TItemElement extends Element,\n>(\n  options: PartialKeys<\n    VirtualizerOptions<TScrollElement, TItemElement>,\n    'observeElementRect' | 'observeElementOffset' | 'scrollToFn'\n  >,\n): Virtualizer<TScrollElement, TItemElement> {\n  return useVirtualizerBase<TScrollElement, TItemElement>({\n    observeElementRect: observeElementRect,\n    observeElementOffset: observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options,\n  })\n}\n\nexport function useWindowVirtualizer<TItemElement extends Element>(\n  options: PartialKeys<\n    VirtualizerOptions<Window, TItemElement>,\n    | 'getScrollElement'\n    | 'observeElementRect'\n    | 'observeElementOffset'\n    | 'scrollToFn'\n  >,\n): Virtualizer<Window, TItemElement> {\n  return useVirtualizerBase<Window, TItemElement>({\n    getScrollElement: () => (typeof document !== 'undefined' ? window : null),\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    initialOffset: () => (typeof document !== 'undefined' ? window.scrollY : 0),\n    ...options,\n  })\n}\n"],"names":["instance","opts"],"mappings":"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","ignoreList":[0,1,2]}