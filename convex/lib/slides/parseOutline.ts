/**
 * Outline Parser
 *
 * Parses markdown outline generated by GLM-4.6 into structured slide data.
 */

export interface ParsedSlide {
  position: number;
  slideType: "title" | "section" | "content";
  title: string;
  content: string;
  speakerNotes?: string;
}

/**
 * Parse markdown outline into structured slide data
 *
 * Supports multiple formats:
 * - # TITLE SLIDE / ## TITLE SLIDE
 * - # SECTION: [name] / ## SECTION: [name]
 * - # Slide N: [title] / ## Slide N: [title]
 * - **Slide N: [title]** (bold format)
 */
export function parseOutlineMarkdown(content: string): ParsedSlide[] {
  const slides: ParsedSlide[] = [];
  let currentSlide: Partial<ParsedSlide> | null = null;
  let position = 0;

  const lines = content.split("\n");

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip empty lines
    if (!trimmed) continue;

    // Check for slide header - supports # or ## or ### or **bold**
    const headerMatch =
      trimmed.match(/^(#{1,3})\s+(.+)$/) ||
      trimmed.match(/^\*\*(.+?)\*\*:?\s*$/);

    if (headerMatch) {
      // Save previous slide if exists
      if (currentSlide?.title) {
        slides.push({
          position: ++position,
          slideType: currentSlide.slideType || "content",
          title: currentSlide.title,
          content: currentSlide.content || "",
          speakerNotes: currentSlide.speakerNotes,
        });
      }

      // Extract title text (group 2 for # headers, group 1 for **bold**)
      const titleText = (headerMatch[2] || headerMatch[1]).trim();
      currentSlide = {
        title: cleanSlideTitle(titleText),
        content: "",
        slideType: "content", // Default, will be overridden
      };

      // Determine type from header
      const lowerTitle = titleText.toLowerCase();
      if (
        lowerTitle.includes("title slide") ||
        lowerTitle.includes("cover slide")
      ) {
        currentSlide.slideType = "title";
      } else if (
        lowerTitle.startsWith("section:") ||
        lowerTitle.startsWith("section -")
      ) {
        currentSlide.slideType = "section";
        // Extract section name as title
        currentSlide.title = titleText.replace(/^section[:-]\s*/i, "").trim();
      }
    }
    // Title field
    else if (trimmed.startsWith("Title:")) {
      if (currentSlide) {
        currentSlide.title = trimmed.substring(6).trim();
      }
    }
    // Subtitle field (append to content for title slides)
    else if (trimmed.startsWith("Subtitle:")) {
      if (currentSlide && currentSlide.slideType === "title") {
        const subtitle = trimmed.substring(9).trim();
        currentSlide.content = subtitle;
      }
    }
    // Type field
    else if (trimmed.startsWith("Type:")) {
      const typeValue = trimmed.substring(5).trim().toLowerCase();
      if (currentSlide && ["title", "section", "content"].includes(typeValue)) {
        currentSlide.slideType = typeValue as "title" | "section" | "content";
      }
    }
    // Speaker Notes field
    else if (trimmed.startsWith("Speaker Notes:")) {
      if (currentSlide) {
        currentSlide.speakerNotes = trimmed.substring(14).trim();
      }
    }
    // Bullet point
    else if (trimmed.startsWith("- ")) {
      if (currentSlide) {
        const bullet = trimmed.substring(2).trim();
        currentSlide.content = currentSlide.content
          ? `${currentSlide.content}\n- ${bullet}`
          : `- ${bullet}`;
      }
    }
    // Numbered bullet (1. 2. 3.)
    else if (/^\d+\.\s/.test(trimmed)) {
      if (currentSlide) {
        const bullet = trimmed.replace(/^\d+\.\s*/, "").trim();
        currentSlide.content = currentSlide.content
          ? `${currentSlide.content}\n- ${bullet}`
          : `- ${bullet}`;
      }
    }
  }

  // Add final slide
  if (currentSlide?.title) {
    slides.push({
      position: ++position,
      slideType: currentSlide.slideType || "content",
      title: currentSlide.title,
      content: currentSlide.content || "",
      speakerNotes: currentSlide.speakerNotes,
    });
  }

  return slides;
}

/**
 * Clean slide title by removing common prefixes
 */
function cleanSlideTitle(title: string): string {
  return title.replace(/^(TITLE SLIDE|SECTION:|Slide \d+:)\s*/i, "").trim();
}
