/**
 * Outline Parser
 *
 * Parses markdown outline generated by GLM-4.6 into structured slide data.
 * Supports presentation (16:9), carousel (1:1), and story (9:16) formats.
 */

// All supported slide types across formats
export type SlideType =
  // Presentation types (16:9)
  | "title"
  | "section"
  | "content"
  // Carousel/Story types (1:1, 9:16)
  | "hook"
  | "rehook"
  | "value"
  | "cta"
  // Narrative beat types (emotional arc)
  | "context"
  | "validation"
  | "reality"
  | "emotional"
  | "reframe"
  | "affirmation";

export interface ParsedSlide {
  position: number;
  slideType: SlideType;
  title: string;
  content: string;
  speakerNotes?: string;
  visualDirection?: string; // Mood, colors, imagery guidance
}

// Valid type values for parsing
const VALID_SLIDE_TYPES: SlideType[] = [
  "title",
  "section",
  "content",
  "hook",
  "rehook",
  "value",
  "cta",
  "context",
  "validation",
  "reality",
  "emotional",
  "reframe",
  "affirmation",
];

/**
 * Parse markdown outline into structured slide data
 *
 * Supports multiple formats:
 * - # TITLE SLIDE / ## TITLE SLIDE
 * - # SECTION: [name] / ## SECTION: [name]
 * - # Slide N: [title] / ## Slide N: [title]
 * - **Slide N: [title]** (bold format)
 */
export function parseOutlineMarkdown(content: string): ParsedSlide[] {
  const slides: ParsedSlide[] = [];
  let currentSlide: Partial<ParsedSlide> | null = null;
  let position = 0;
  // Track which field we're accumulating for multi-line content
  let currentField: "title" | "visual" | "speakerNotes" | "content" | null =
    null;

  const lines = content.split("\n");

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip empty lines
    if (!trimmed) continue;

    // Check for slide header - supports # or ## or ### or **bold**
    const headerMatch =
      trimmed.match(/^(#{1,3})\s+(.+)$/) ||
      trimmed.match(/^\*\*(.+?)\*\*:?\s*$/);

    if (headerMatch) {
      // Reset field tracking - new slide starts
      currentField = null;

      // Save previous slide if exists
      if (currentSlide?.title) {
        slides.push({
          position: ++position,
          slideType: currentSlide.slideType || "content",
          title: currentSlide.title,
          content: currentSlide.content || "",
          speakerNotes: currentSlide.speakerNotes,
          visualDirection: currentSlide.visualDirection,
        });
      }

      // Extract title text (group 2 for # headers, group 1 for **bold**)
      const titleText = (headerMatch[2] || headerMatch[1]).trim();
      currentSlide = {
        title: cleanSlideTitle(titleText),
        content: "",
        slideType: "content", // Default, will be overridden
      };

      // Determine type from header
      const lowerTitle = titleText.toLowerCase();

      // Presentation types
      if (
        lowerTitle.includes("title slide") ||
        lowerTitle.includes("cover slide")
      ) {
        currentSlide.slideType = "title";
      } else if (
        lowerTitle.startsWith("section:") ||
        lowerTitle.startsWith("section -")
      ) {
        currentSlide.slideType = "section";
        // Extract section name as title
        currentSlide.title = titleText.replace(/^section[:-]\s*/i, "").trim();
      }
      // Carousel types
      else if (lowerTitle === "hook" || lowerTitle.includes("(hook)")) {
        currentSlide.slideType = "hook";
        currentSlide.title = cleanSlideTitle(titleText);
      } else if (
        lowerTitle.includes("value promise") ||
        lowerTitle.includes("(rehook)") ||
        lowerTitle === "rehook"
      ) {
        currentSlide.slideType = "rehook";
        currentSlide.title = cleanSlideTitle(titleText);
      } else if (
        lowerTitle.includes("value slide") ||
        lowerTitle.includes("(value)")
      ) {
        currentSlide.slideType = "value";
        currentSlide.title = cleanSlideTitle(titleText);
      } else if (
        lowerTitle.includes("call to action") ||
        lowerTitle.includes("cta") ||
        lowerTitle.includes("final slide")
      ) {
        currentSlide.slideType = "cta";
        currentSlide.title = cleanSlideTitle(titleText);
      }
      // Story types (frame-based)
      else if (
        lowerTitle.includes("frame 1") ||
        lowerTitle.includes("frame 1 (hook)")
      ) {
        currentSlide.slideType = "hook";
        currentSlide.title = cleanSlideTitle(titleText);
      } else if (lowerTitle.includes("final frame")) {
        currentSlide.slideType = "cta";
        currentSlide.title = cleanSlideTitle(titleText);
      } else if (/frame \d+/.test(lowerTitle)) {
        currentSlide.slideType = "content";
        currentSlide.title = cleanSlideTitle(titleText);
      }
      // Narrative beat types (from header or parenthetical)
      else if (
        lowerTitle.includes("(context)") ||
        lowerTitle.includes("context")
      ) {
        currentSlide.slideType = "context";
        currentSlide.title = cleanSlideTitle(titleText);
      } else if (
        lowerTitle.includes("(validation)") ||
        lowerTitle.includes("validation")
      ) {
        currentSlide.slideType = "validation";
        currentSlide.title = cleanSlideTitle(titleText);
      } else if (
        lowerTitle.includes("(reality)") ||
        lowerTitle.includes("reality check")
      ) {
        currentSlide.slideType = "reality";
        currentSlide.title = cleanSlideTitle(titleText);
      } else if (
        lowerTitle.includes("(emotional)") ||
        lowerTitle.includes("emotional layer")
      ) {
        currentSlide.slideType = "emotional";
        currentSlide.title = cleanSlideTitle(titleText);
      } else if (
        lowerTitle.includes("(reframe)") ||
        lowerTitle.includes("reframe")
      ) {
        currentSlide.slideType = "reframe";
        currentSlide.title = cleanSlideTitle(titleText);
      } else if (
        lowerTitle.includes("(affirmation)") ||
        lowerTitle.includes("affirmation")
      ) {
        currentSlide.slideType = "affirmation";
        currentSlide.title = cleanSlideTitle(titleText);
      }
    }
    // Title field
    else if (trimmed.startsWith("Title:")) {
      currentField = "title";
      if (currentSlide) {
        currentSlide.title = trimmed.substring(6).trim();
      }
    }
    // Subtitle field (append to content for title slides)
    else if (trimmed.startsWith("Subtitle:")) {
      currentField = "content";
      if (currentSlide && currentSlide.slideType === "title") {
        const subtitle = trimmed.substring(9).trim();
        currentSlide.content = subtitle;
      }
    }
    // Type field (always single-line)
    else if (trimmed.startsWith("Type:")) {
      currentField = null;
      const typeValue = trimmed.substring(5).trim().toLowerCase();
      if (currentSlide && VALID_SLIDE_TYPES.includes(typeValue as SlideType)) {
        currentSlide.slideType = typeValue as SlideType;
      }
    }
    // Supporting field (for carousel slides)
    else if (trimmed.startsWith("Supporting:")) {
      currentField = "content";
      if (currentSlide) {
        const supporting = trimmed.substring(11).trim();
        currentSlide.content = currentSlide.content
          ? `${currentSlide.content}\n${supporting}`
          : supporting;
      }
    }
    // Handle field (for carousel CTA slides)
    else if (trimmed.startsWith("Handle:")) {
      currentField = "content";
      if (currentSlide) {
        const handle = trimmed.substring(7).trim();
        currentSlide.content = currentSlide.content
          ? `${currentSlide.content}\n${handle}`
          : handle;
      }
    }
    // Visual field (mood, colors, imagery guidance)
    else if (trimmed.startsWith("Visual:")) {
      currentField = "visual";
      if (currentSlide) {
        currentSlide.visualDirection = trimmed.substring(7).trim();
      }
    }
    // Speaker Notes field
    else if (trimmed.startsWith("Speaker Notes:")) {
      currentField = "speakerNotes";
      if (currentSlide) {
        currentSlide.speakerNotes = trimmed.substring(14).trim();
      }
    }
    // Bullet point
    else if (trimmed.startsWith("- ")) {
      currentField = "content";
      if (currentSlide) {
        const bullet = trimmed.substring(2).trim();
        currentSlide.content = currentSlide.content
          ? `${currentSlide.content}\n- ${bullet}`
          : `- ${bullet}`;
      }
    }
    // Numbered bullet (1. 2. 3.)
    else if (/^\d+\.\s/.test(trimmed)) {
      currentField = "content";
      if (currentSlide) {
        const bullet = trimmed.replace(/^\d+\.\s*/, "").trim();
        currentSlide.content = currentSlide.content
          ? `${currentSlide.content}\n- ${bullet}`
          : `- ${bullet}`;
      }
    }
    // CONTINUATION LINES - append to current field
    else if (currentField && currentSlide) {
      switch (currentField) {
        case "title":
          currentSlide.title = `${currentSlide.title || ""} ${trimmed}`;
          break;
        case "visual":
          currentSlide.visualDirection = `${currentSlide.visualDirection || ""} ${trimmed}`;
          break;
        case "speakerNotes":
          currentSlide.speakerNotes = `${currentSlide.speakerNotes || ""} ${trimmed}`;
          break;
        case "content":
          currentSlide.content = `${currentSlide.content || ""}\n${trimmed}`;
          break;
      }
    }
  }

  // Add final slide
  if (currentSlide?.title) {
    slides.push({
      position: ++position,
      slideType: currentSlide.slideType || "content",
      title: currentSlide.title,
      content: currentSlide.content || "",
      speakerNotes: currentSlide.speakerNotes,
      visualDirection: currentSlide.visualDirection,
    });
  }

  return slides;
}

/**
 * Clean slide title by removing common prefixes
 */
function cleanSlideTitle(title: string): string {
  return title
    .replace(
      /^(TITLE SLIDE|SECTION:|Slide \d+:|HOOK|FRAME \d+|FINAL FRAME|FINAL SLIDE|VALUE PROMISE|\(Hook\)|\(Rehook\)|\(Value\)|\(CTA\)|Call to Action|\(Context\)|Context|\(Validation\)|Validation|\(Reality\)|Reality Check|\(Emotional\)|Emotional Layer|\(Reframe\)|Reframe|\(Affirmation\)|Affirmation)[:\s-]*/i,
      "",
    )
    .trim();
}
