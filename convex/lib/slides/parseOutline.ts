/**
 * Outline Parser
 *
 * Parses markdown outline generated by GLM-4.6 into structured slide data.
 */

export interface ParsedSlide {
  position: number;
  slideType: "title" | "section" | "content";
  title: string;
  content: string;
  speakerNotes?: string;
}

/**
 * Parse markdown outline into structured slide data
 *
 * Expected format:
 * # TITLE SLIDE
 * Title: [title]
 * Subtitle: [subtitle]
 * Type: title
 *
 * # SECTION: [name]
 * Title: [title]
 * Type: section
 *
 * # Slide N: [title]
 * - bullet 1
 * - bullet 2
 * Type: content
 * Speaker Notes: [notes]
 */
export function parseOutlineMarkdown(content: string): ParsedSlide[] {
  const slides: ParsedSlide[] = [];
  let currentSlide: Partial<ParsedSlide> | null = null;
  let position = 0;

  const lines = content.split("\n");

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip empty lines
    if (!trimmed) continue;

    // Slide header (starts with #)
    if (trimmed.startsWith("# ")) {
      // Save previous slide if exists
      if (currentSlide && currentSlide.title) {
        slides.push({
          position: ++position,
          slideType: currentSlide.slideType || "content",
          title: currentSlide.title,
          content: currentSlide.content || "",
          speakerNotes: currentSlide.speakerNotes,
        });
      }

      // Start new slide
      const titleText = trimmed.substring(2).trim();
      currentSlide = {
        title: cleanSlideTitle(titleText),
        content: "",
        slideType: "content", // Default, will be overridden
      };

      // Determine type from header
      if (trimmed.toLowerCase().includes("title slide")) {
        currentSlide.slideType = "title";
      } else if (trimmed.toLowerCase().startsWith("# section:")) {
        currentSlide.slideType = "section";
        // Extract section name as title
        currentSlide.title = titleText.replace(/^section:\s*/i, "").trim();
      }
    }
    // Title field
    else if (trimmed.startsWith("Title:")) {
      if (currentSlide) {
        currentSlide.title = trimmed.substring(6).trim();
      }
    }
    // Subtitle field (append to content for title slides)
    else if (trimmed.startsWith("Subtitle:")) {
      if (currentSlide && currentSlide.slideType === "title") {
        const subtitle = trimmed.substring(9).trim();
        currentSlide.content = subtitle;
      }
    }
    // Type field
    else if (trimmed.startsWith("Type:")) {
      const typeValue = trimmed.substring(5).trim().toLowerCase();
      if (currentSlide && ["title", "section", "content"].includes(typeValue)) {
        currentSlide.slideType = typeValue as "title" | "section" | "content";
      }
    }
    // Speaker Notes field
    else if (trimmed.startsWith("Speaker Notes:")) {
      if (currentSlide) {
        currentSlide.speakerNotes = trimmed.substring(14).trim();
      }
    }
    // Bullet point
    else if (trimmed.startsWith("- ")) {
      if (currentSlide) {
        const bullet = trimmed.substring(2).trim();
        currentSlide.content = currentSlide.content
          ? `${currentSlide.content}\n- ${bullet}`
          : `- ${bullet}`;
      }
    }
    // Numbered bullet (1. 2. 3.)
    else if (/^\d+\.\s/.test(trimmed)) {
      if (currentSlide) {
        const bullet = trimmed.replace(/^\d+\.\s*/, "").trim();
        currentSlide.content = currentSlide.content
          ? `${currentSlide.content}\n- ${bullet}`
          : `- ${bullet}`;
      }
    }
  }

  // Add final slide
  if (currentSlide && currentSlide.title) {
    slides.push({
      position: ++position,
      slideType: currentSlide.slideType || "content",
      title: currentSlide.title,
      content: currentSlide.content || "",
      speakerNotes: currentSlide.speakerNotes,
    });
  }

  return slides;
}

/**
 * Clean slide title by removing common prefixes
 */
function cleanSlideTitle(title: string): string {
  return title.replace(/^(TITLE SLIDE|SECTION:|Slide \d+:)\s*/i, "").trim();
}
