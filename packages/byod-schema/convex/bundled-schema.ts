// Auto-generated BYOD schema v9
// DO NOT EDIT - Self-contained schema for standalone deployment

import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

// === CONVERSATIONS ===
export const conversationsTable = defineTable({
  userId: v.id("users"),
  title: v.string(),
  model: v.string(),
  pinned: v.boolean(),
  archived: v.boolean(),
  starred: v.boolean(),
  systemPrompt: v.optional(v.string()),
  projectId: v.optional(v.id("projects")),
  lastMemoryExtractionAt: v.optional(v.number()),
  memoryExtractionMessageCount: v.optional(v.number()),
  // Phase 2B: Memory caching
  cachedMemoryIds: v.optional(v.array(v.id("memories"))),
  lastMemoryFetchAt: v.optional(v.number()),
  // Incremental extraction cursor
  lastExtractedMessageId: v.optional(v.id("messages")),
  // Token usage tracking
  tokenUsage: v.optional(
    v.object({
      systemTokens: v.number(),
      messagesTokens: v.number(),
      memoriesTokens: v.number(),
      totalTokens: v.number(),
      contextLimit: v.number(),
      lastCalculatedAt: v.number(),
    }),
  ),
  messageCount: v.optional(v.number()),
  lastMessageAt: v.number(),
  // Branching support
  parentConversationId: v.optional(v.id("conversations")),
  parentMessageId: v.optional(v.id("messages")),
  // Collaborative conversations (multi-user)
  isCollaborative: v.optional(v.boolean()),
  // Incognito mode (ephemeral conversations)
  isIncognito: v.optional(v.boolean()),
  incognitoSettings: v.optional(
    v.object({
      enableReadTools: v.boolean(),
      applyCustomInstructions: v.boolean(),
      inactivityTimeoutMinutes: v.optional(v.number()),
      scheduledDeletionId: v.optional(v.id("_scheduled_functions")),
      lastActivityAt: v.number(),
    }),
  ),
  // Presentation mode (slides feature conversations)
  isPresentation: v.optional(v.boolean()),
  // Enable web search grounding for presentations
  enableGrounding: v.optional(v.boolean()),
  // Presentation metadata
  slideStyle: v.optional(
    v.union(v.literal("wordy"), v.literal("illustrative")),
  ),
  imageStyle: v.optional(v.string()),
  aspectRatio: v.optional(
    v.union(v.literal("16:9"), v.literal("1:1"), v.literal("9:16")),
  ),
  templateId: v.optional(v.id("templates")),
  // Model recommendation (cost optimization & decision guidance)
  modelRecommendation: v.optional(
    v.object({
      suggestedModelId: v.string(),
      currentModelId: v.string(),
      reasoning: v.string(),
      estimatedSavings: v.object({
        costReduction: v.string(),
        percentSaved: v.number(),
      }),
      createdAt: v.number(),
      dismissed: v.boolean(),
    }),
  ),
  // Document mode (Canvas)
  mode: v.optional(v.union(v.literal("document"), v.literal("normal"))),
  modeActivatedAt: v.optional(v.number()),
  // Cached system prompt (built in background on creation/input changes)
  cachedSystemPrompt: v.optional(v.string()),
  promptInputHash: v.optional(v.string()),
  promptBuiltAt: v.optional(v.number()),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_user_pinned", ["userId", "pinned"])
  .index("by_projectId", ["projectId"])
  .index("by_parent_conversation", ["parentConversationId"])
  .searchIndex("search_title", {
    searchField: "title",
    filterFields: ["userId", "archived"],
  });

export const conversationParticipantsTable = defineTable({
  conversationId: v.id("conversations"),
  userId: v.id("users"),
  role: v.union(v.literal("owner"), v.literal("collaborator")),
  joinedAt: v.number(),
  invitedBy: v.optional(v.id("users")),
  sourceShareId: v.optional(v.string()),
})
  .index("by_conversation", ["conversationId"])
  .index("by_user", ["userId"])
  .index("by_user_conversation", ["userId", "conversationId"]);

export const conversationTokenUsageTable = defineTable({
  conversationId: v.id("conversations"),
  model: v.string(),
  totalTokens: v.number(),
  inputTokens: v.number(),
  outputTokens: v.number(),
  reasoningTokens: v.optional(v.number()),
  messageCount: v.number(),
  lastUpdatedAt: v.number(),
  createdAt: v.number(),
})
  .index("by_conversation", ["conversationId"])
  .index("by_conversation_model", ["conversationId", "model"]);

// === MESSAGES ===
export const messagesTable = defineTable({
  conversationId: v.id("conversations"),
  userId: v.optional(v.id("users")),
  role: v.union(v.literal("user"), v.literal("assistant"), v.literal("system")),
  content: v.string(),
  partialContent: v.optional(v.string()),
  status: v.union(
    v.literal("pending"),
    v.literal("generating"),
    v.literal("complete"),
    v.literal("stopped"),
    v.literal("error"),
  ),
  model: v.optional(v.string()),
  inputTokens: v.optional(v.number()),
  outputTokens: v.optional(v.number()),
  cost: v.optional(v.number()),
  // Reasoning/thinking support
  reasoning: v.optional(v.string()),
  partialReasoning: v.optional(v.string()),
  reasoningTokens: v.optional(v.number()),
  thinkingStartedAt: v.optional(v.number()),
  thinkingCompletedAt: v.optional(v.number()),
  error: v.optional(v.string()),
  embedding: v.optional(v.array(v.float64())),
  // Provider specific metadata
  providerMetadata: v.optional(v.any()),
  // Branching support
  parentMessageId: v.optional(v.id("messages")),
  branchLabel: v.optional(v.string()),
  branchIndex: v.optional(v.number()),
  // Comparison support
  comparisonGroupId: v.optional(v.string()),
  consolidatedMessageId: v.optional(v.id("messages")),
  isConsolidation: v.optional(v.boolean()),
  votes: v.optional(
    v.object({
      rating: v.union(
        v.literal("left_better"),
        v.literal("right_better"),
        v.literal("tie"),
        v.literal("both_bad"),
      ),
      isWinner: v.boolean(),
      votedAt: v.number(),
    }),
  ),
  generationStartedAt: v.optional(v.number()),
  generationCompletedAt: v.optional(v.number()),
  // Performance metrics
  apiCallStartedAt: v.optional(v.number()), // When LLM API call made (for true TTFT)
  firstTokenAt: v.optional(v.number()),
  tokensPerSecond: v.optional(v.number()),
  // Memory extraction tracking
  memoryExtracted: v.optional(v.boolean()),
  memoryExtractedAt: v.optional(v.number()),
  // DEPRECATED: Source citations migrated to normalized tables
  sources: v.optional(
    v.array(
      v.object({
        id: v.string(),
        title: v.string(),
        url: v.string(),
        publishedDate: v.optional(v.string()),
        snippet: v.optional(v.string()),
      }),
    ),
  ),
  partialSources: v.optional(
    v.array(
      v.object({
        id: v.string(),
        title: v.string(),
        url: v.string(),
        publishedDate: v.optional(v.string()),
        snippet: v.optional(v.string()),
      }),
    ),
  ),
  sourceMetadata: v.optional(
    v.array(
      v.object({
        sourceId: v.string(),
        ogTitle: v.optional(v.string()),
        ogDescription: v.optional(v.string()),
        ogImage: v.optional(v.string()),
        favicon: v.optional(v.string()),
        domain: v.string(),
        fetchedAt: v.optional(v.number()),
        error: v.optional(v.string()),
      }),
    ),
  ),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_conversation", ["conversationId"])
  .index("by_user", ["userId"])
  .index("by_status", ["status"])
  .index("by_parent", ["parentMessageId"])
  .index("by_comparison_group", ["comparisonGroupId"])
  .index("by_consolidated_message", ["consolidatedMessageId"])
  .index("by_conversation_created", ["conversationId", "createdAt"])
  .index("by_conversation_role", ["conversationId", "role"])
  .vectorIndex("by_embedding", {
    vectorField: "embedding",
    dimensions: 1536,
    filterFields: ["conversationId", "userId"],
  })
  .searchIndex("search_content", {
    searchField: "content",
    filterFields: ["conversationId", "userId", "role"],
  });

export const attachmentsTable = defineTable({
  messageId: v.id("messages"),
  conversationId: v.id("conversations"),
  userId: v.id("users"),
  type: v.union(v.literal("image"), v.literal("file"), v.literal("audio")),
  name: v.string(),
  storageId: v.id("_storage"),
  mimeType: v.string(),
  size: v.number(),
  metadata: v.optional(
    v.object({
      width: v.optional(v.number()),
      height: v.optional(v.number()),
      duration: v.optional(v.number()),
      prompt: v.optional(v.string()),
      model: v.optional(v.string()),
      generationTime: v.optional(v.number()),
    }),
  ),
  createdAt: v.number(),
})
  .index("by_message", ["messageId"])
  .index("by_conversation", ["conversationId"])
  .index("by_user", ["userId"])
  .index("by_storage", ["storageId"]);

export const toolCallsTable = defineTable({
  messageId: v.id("messages"),
  conversationId: v.id("conversations"),
  userId: v.id("users"),
  toolCallId: v.string(),
  toolName: v.string(),
  args: v.any(),
  result: v.optional(v.any()),
  textPosition: v.optional(v.number()),
  isPartial: v.boolean(),
  timestamp: v.number(),
  createdAt: v.number(),
})
  .index("by_message", ["messageId"])
  .index("by_conversation", ["conversationId"])
  .index("by_user", ["userId"])
  .index("by_message_partial", ["messageId", "isPartial"]);

export const sourceMetadataTable = defineTable({
  urlHash: v.string(),
  url: v.string(),
  title: v.optional(v.string()),
  description: v.optional(v.string()),
  ogImage: v.optional(v.string()),
  favicon: v.optional(v.string()),
  siteName: v.optional(v.string()),
  enriched: v.boolean(),
  enrichedAt: v.optional(v.number()),
  enrichmentError: v.optional(v.string()),
  firstSeenAt: v.number(),
  lastAccessedAt: v.number(),
  accessCount: v.number(),
})
  .index("by_urlHash", ["urlHash"])
  .index("by_url", ["url"]);

export const sourcesTable = defineTable({
  messageId: v.id("messages"),
  conversationId: v.id("conversations"),
  userId: v.id("users"),
  position: v.number(),
  provider: v.string(),
  title: v.optional(v.string()),
  snippet: v.optional(v.string()),
  urlHash: v.string(),
  url: v.string(),
  isPartial: v.boolean(),
  createdAt: v.number(),
})
  .index("by_message", ["messageId"])
  .index("by_conversation", ["conversationId", "createdAt"])
  .index("by_urlHash", ["urlHash"])
  .index("by_user", ["userId", "createdAt"]);

// === MEMORIES ===
export const memoriesTable = defineTable({
  userId: v.id("users"),
  content: v.string(),
  embedding: v.array(v.number()),
  conversationId: v.optional(v.id("conversations")),
  sourceMessageId: v.optional(v.id("messages")),
  sourceMessageIds: v.optional(v.array(v.id("messages"))),
  metadata: v.object({
    category: v.string(),
    importance: v.optional(v.number()),
    reasoning: v.optional(v.string()),
    extractedAt: v.optional(v.number()),
    sourceConversationId: v.optional(v.id("conversations")),
    confidence: v.optional(v.number()),
    verifiedBy: v.optional(
      v.union(
        v.literal("auto"),
        v.literal("manual"),
        v.literal("consolidated"),
      ),
    ),
    expiresAt: v.optional(v.number()),
    version: v.optional(v.number()),
    supersededBy: v.optional(v.id("memories")),
    expirationHint: v.optional(
      v.union(
        v.literal("contextual"),
        v.literal("preference"),
        v.literal("deadline"),
        v.literal("temporary"),
      ),
    ),
  }),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_user_category", ["userId", "metadata.category"])
  .index("by_importance", ["userId", "metadata.importance"])
  .index("by_conversation", ["conversationId"])
  .vectorIndex("by_embedding", {
    vectorField: "embedding",
    dimensions: 1536,
    filterFields: ["userId"],
  })
  .searchIndex("search_content", {
    searchField: "content",
    filterFields: ["userId", "metadata.category"],
  });

// === FILES ===
export const filesTable = defineTable({
  userId: v.id("users"),
  conversationId: v.optional(v.id("conversations")),
  storageId: v.id("_storage"),
  name: v.string(),
  mimeType: v.string(),
  size: v.number(),
  chunkCount: v.optional(v.number()),
  embeddingStatus: v.optional(
    v.union(
      v.literal("pending"),
      v.literal("processing"),
      v.literal("completed"),
      v.literal("failed"),
    ),
  ),
  embeddingError: v.optional(v.string()),
  processedAt: v.optional(v.number()),
  createdAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_conversation", ["conversationId"]);

export const fileChunksTable = defineTable({
  fileId: v.id("files"),
  userId: v.id("users"),
  projectId: v.optional(v.id("projects")),
  chunkIndex: v.number(),
  content: v.string(),
  startPage: v.optional(v.number()),
  endPage: v.optional(v.number()),
  section: v.optional(v.string()),
  charOffset: v.number(),
  tokenCount: v.number(),
  embedding: v.array(v.float64()),
  createdAt: v.number(),
})
  .index("by_file", ["fileId"])
  .index("by_user", ["userId"])
  .index("by_project", ["projectId"])
  .vectorIndex("by_embedding", {
    vectorField: "embedding",
    dimensions: 1536,
    filterFields: ["userId", "projectId"],
  });

export const knowledgeSourcesTable = defineTable({
  userId: v.id("users"),
  projectId: v.optional(v.id("projects")),
  type: v.union(
    v.literal("file"),
    v.literal("text"),
    v.literal("web"),
    v.literal("youtube"),
  ),
  title: v.string(),
  description: v.optional(v.string()),
  storageId: v.optional(v.id("_storage")),
  url: v.optional(v.string()),
  rawContent: v.optional(v.string()),
  videoMetadata: v.optional(
    v.object({
      videoId: v.string(),
      duration: v.optional(v.number()),
      channel: v.optional(v.string()),
      thumbnailUrl: v.optional(v.string()),
    }),
  ),
  mimeType: v.optional(v.string()),
  size: v.optional(v.number()),
  status: v.union(
    v.literal("pending"),
    v.literal("processing"),
    v.literal("completed"),
    v.literal("failed"),
  ),
  error: v.optional(v.string()),
  chunkCount: v.optional(v.number()),
  processedAt: v.optional(v.number()),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_project", ["projectId"])
  .index("by_user_type", ["userId", "type"])
  .index("by_user_project", ["userId", "projectId"])
  .index("by_status", ["status"]);

export const knowledgeChunksTable = defineTable({
  sourceId: v.id("knowledgeSources"),
  userId: v.id("users"),
  projectId: v.optional(v.id("projects")),
  content: v.string(),
  chunkIndex: v.number(),
  charOffset: v.number(),
  tokenCount: v.number(),
  startTime: v.optional(v.string()),
  endTime: v.optional(v.string()),
  pageNumber: v.optional(v.number()),
  embedding: v.array(v.float64()),
  createdAt: v.number(),
})
  .index("by_source", ["sourceId"])
  .index("by_user", ["userId"])
  .index("by_project", ["projectId"])
  .vectorIndex("by_embedding", {
    vectorField: "embedding",
    dimensions: 1536,
    filterFields: ["userId", "projectId"],
  });

// === PROJECTS ===
export const projectsTable = defineTable({
  userId: v.id("users"),
  name: v.string(),
  description: v.optional(v.string()),
  systemPrompt: v.optional(v.string()),
  isTemplate: v.optional(v.boolean()),
  createdFrom: v.optional(v.id("projects")),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_userId_isTemplate", ["userId", "isTemplate"]);

export const projectConversationsTable = defineTable({
  projectId: v.id("projects"),
  conversationId: v.id("conversations"),
  addedAt: v.number(),
  addedBy: v.id("users"),
})
  .index("by_project", ["projectId"])
  .index("by_conversation", ["conversationId"])
  .index("by_project_conversation", ["projectId", "conversationId"]);

export const projectNotesTable = defineTable({
  projectId: v.id("projects"),
  noteId: v.id("notes"),
  userId: v.id("users"),
  addedAt: v.number(),
})
  .index("by_project", ["projectId"])
  .index("by_note", ["noteId"])
  .index("by_user_project", ["userId", "projectId"])
  .index("by_project_note", ["projectId", "noteId"]);

export const projectFilesTable = defineTable({
  projectId: v.id("projects"),
  fileId: v.id("files"),
  userId: v.id("users"),
  addedAt: v.number(),
})
  .index("by_project", ["projectId"])
  .index("by_file", ["fileId"])
  .index("by_user_project", ["userId", "projectId"])
  .index("by_project_file", ["projectId", "fileId"]);

// === TASKS ===
export const tasksTable = defineTable({
  userId: v.id("users"),
  title: v.string(),
  description: v.optional(v.string()),
  status: v.union(
    v.literal("suggested"),
    v.literal("confirmed"),
    v.literal("in_progress"),
    v.literal("completed"),
    v.literal("cancelled"),
  ),
  deadline: v.optional(v.number()),
  deadlineSource: v.optional(v.string()),
  urgency: v.optional(
    v.union(
      v.literal("low"),
      v.literal("medium"),
      v.literal("high"),
      v.literal("urgent"),
    ),
  ),
  tags: v.optional(v.array(v.string())),
  sourceType: v.optional(
    v.union(
      v.literal("transcript"),
      v.literal("conversation"),
      v.literal("manual"),
      v.literal("file"),
    ),
  ),
  sourceId: v.optional(v.string()),
  sourceContext: v.optional(
    v.object({
      snippet: v.optional(v.string()),
      timestampSeconds: v.optional(v.number()),
      confidence: v.optional(v.number()),
    }),
  ),
  projectId: v.optional(v.id("projects")),
  priority: v.optional(v.number()),
  position: v.optional(v.number()),
  completedAt: v.optional(v.number()),
  embedding: v.optional(v.array(v.float64())),
  embeddingStatus: v.optional(
    v.union(
      v.literal("pending"),
      v.literal("processing"),
      v.literal("completed"),
      v.literal("failed"),
    ),
  ),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_user_status", ["userId", "status"])
  .index("by_user_deadline", ["userId", "deadline"])
  .index("by_project", ["projectId"])
  .index("by_user_project", ["userId", "projectId"])
  .searchIndex("search_title", {
    searchField: "title",
    filterFields: ["userId", "status", "projectId"],
  })
  .vectorIndex("by_embedding", {
    vectorField: "embedding",
    dimensions: 1536,
    filterFields: ["userId", "projectId"],
  });

// === NOTES ===
export const notesTable = defineTable({
  userId: v.id("users"),
  title: v.string(),
  content: v.string(),
  htmlContent: v.optional(v.string()),
  sourceMessageId: v.optional(v.id("messages")),
  sourceConversationId: v.optional(v.id("conversations")),
  sourceSelectionText: v.optional(v.string()),
  projectId: v.optional(v.id("projects")),
  tags: v.optional(v.array(v.string())),
  suggestedTags: v.optional(v.array(v.string())),
  isPinned: v.boolean(),
  shareId: v.optional(v.string()),
  isPublic: v.optional(v.boolean()),
  sharePassword: v.optional(v.string()),
  shareExpiresAt: v.optional(v.number()),
  shareCreatedAt: v.optional(v.number()),
  shareViewCount: v.optional(v.number()),
  embedding: v.optional(v.array(v.float64())),
  embeddingStatus: v.optional(
    v.union(
      v.literal("pending"),
      v.literal("processing"),
      v.literal("completed"),
      v.literal("failed"),
    ),
  ),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_user_updated", ["userId", "updatedAt"])
  .index("by_source_message", ["sourceMessageId"])
  .index("by_share_id", ["shareId"])
  .index("by_projectId", ["projectId"])
  .searchIndex("search_notes", {
    searchField: "content",
    filterFields: ["userId"],
  })
  .vectorIndex("by_embedding", {
    vectorField: "embedding",
    dimensions: 1536,
    filterFields: ["userId", "projectId"],
  });

// === BOOKMARKS ===
export const bookmarksTable = defineTable({
  userId: v.id("users"),
  messageId: v.id("messages"),
  conversationId: v.id("conversations"),
  note: v.optional(v.string()),
  tags: v.optional(v.array(v.string())),
  createdAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_message", ["messageId"])
  .index("by_conversation", ["conversationId"])
  .index("by_user_created", ["userId", "createdAt"]);

export const snippetsTable = defineTable({
  userId: v.id("users"),
  text: v.string(),
  sourceMessageId: v.id("messages"),
  sourceConversationId: v.id("conversations"),
  note: v.optional(v.string()),
  tags: v.optional(v.array(v.string())),
  createdAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_message", ["sourceMessageId"])
  .index("by_conversation", ["sourceConversationId"])
  .searchIndex("search_text", {
    searchField: "text",
    filterFields: ["userId"],
  });

// === TAGS ===
export const tagsTable = defineTable({
  slug: v.string(),
  displayName: v.string(),
  userId: v.optional(v.id("users")),
  scope: v.union(v.literal("user"), v.literal("global")),
  parentId: v.optional(v.id("tags")),
  path: v.string(),
  depth: v.number(),
  usageCount: v.number(),
  color: v.optional(v.string()),
  description: v.optional(v.string()),
  embedding: v.optional(v.array(v.float64())),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user_slug", ["userId", "slug"])
  .index("by_user_usage", ["userId", "usageCount"])
  .index("by_scope", ["scope"])
  .index("by_parent", ["parentId"])
  .index("by_user_path", ["userId", "path"]);

export const bookmarkTagsTable = defineTable({
  bookmarkId: v.id("bookmarks"),
  tagId: v.id("tags"),
  userId: v.id("users"),
  createdAt: v.number(),
})
  .index("by_bookmark", ["bookmarkId"])
  .index("by_tag", ["tagId"])
  .index("by_user", ["userId"])
  .index("by_bookmark_tag", ["bookmarkId", "tagId"]);

export const snippetTagsTable = defineTable({
  snippetId: v.id("snippets"),
  tagId: v.id("tags"),
  userId: v.id("users"),
  createdAt: v.number(),
})
  .index("by_snippet", ["snippetId"])
  .index("by_tag", ["tagId"])
  .index("by_user", ["userId"])
  .index("by_snippet_tag", ["snippetId", "tagId"]);

export const noteTagsTable = defineTable({
  noteId: v.id("notes"),
  tagId: v.id("tags"),
  userId: v.id("users"),
  createdAt: v.number(),
})
  .index("by_note", ["noteId"])
  .index("by_tag", ["tagId"])
  .index("by_user", ["userId"])
  .index("by_note_tag", ["noteId", "tagId"]);

export const taskTagsTable = defineTable({
  taskId: v.id("tasks"),
  tagId: v.id("tags"),
  userId: v.id("users"),
  addedAt: v.number(),
})
  .index("by_task", ["taskId"])
  .index("by_tag", ["tagId"])
  .index("by_user", ["userId"])
  .index("by_task_tag", ["taskId", "tagId"]);

// === SHARES ===
export const sharesTable = defineTable({
  userId: v.id("users"),
  conversationId: v.id("conversations"),
  shareId: v.string(),
  title: v.string(),
  expiresAt: v.optional(v.number()),
  isPublic: v.boolean(),
  isActive: v.boolean(),
  password: v.optional(v.string()),
  anonymizeUsernames: v.optional(v.boolean()),
  viewCount: v.number(),
  createdAt: v.number(),
})
  .index("by_share_id", ["shareId"])
  .index("by_user", ["userId"])
  .index("by_conversation", ["conversationId"]);

export const scheduledPromptsTable = defineTable({
  userId: v.id("users"),
  prompt: v.string(),
  schedule: v.object({
    type: v.union(
      v.literal("daily"),
      v.literal("weekly"),
      v.literal("monthly"),
    ),
    time: v.string(),
    dayOfWeek: v.optional(v.number()),
    dayOfMonth: v.optional(v.number()),
    timezone: v.string(),
  }),
  model: v.string(),
  projectId: v.optional(v.id("projects")),
  isActive: v.boolean(),
  lastRunAt: v.optional(v.number()),
  nextRunAt: v.number(),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_next_run", ["nextRunAt", "isActive"]);

// === USAGE ===
export const usageRecordsTable = defineTable({
  userId: v.id("users"),
  date: v.string(),
  model: v.string(),
  conversationId: v.optional(v.id("conversations")),
  presentationId: v.optional(v.id("presentations")),
  feature: v.optional(
    v.union(
      v.literal("chat"),
      v.literal("slides"),
      v.literal("notes"),
      v.literal("tasks"),
      v.literal("files"),
      v.literal("memory"),
      v.literal("smart_assistant"),
    ),
  ),
  operationType: v.optional(
    v.union(
      v.literal("text"),
      v.literal("tts"),
      v.literal("stt"),
      v.literal("image"),
      v.literal("embedding"),
    ),
  ),
  inputTokens: v.number(),
  outputTokens: v.number(),
  reasoningTokens: v.optional(v.number()),
  cost: v.number(),
  messageCount: v.number(),
  warningsSent: v.optional(v.array(v.string())),
  isByok: v.optional(v.boolean()),
})
  .index("by_user_date", ["userId", "date"])
  .index("by_user", ["userId"])
  .index("by_user_date_model", ["userId", "date", "model"])
  .index("by_conversation", ["conversationId"])
  .index("by_presentation", ["presentationId"])
  .index("by_user_feature", ["userId", "feature"]);

export const ttsCacheTable = defineTable({
  hash: v.string(),
  storageId: v.id("_storage"),
  text: v.string(),
  voice: v.string(),
  speed: v.number(),
  format: v.string(),
  createdAt: v.number(),
  lastAccessedAt: v.number(),
}).index("by_hash", ["hash"]);

// === TEMPLATES ===
export const templatesTable = defineTable({
  userId: v.optional(v.id("users")),
  name: v.string(),
  prompt: v.string(),
  description: v.optional(v.string()),
  category: v.string(),
  isBuiltIn: v.boolean(),
  isPublic: v.boolean(),
  usageCount: v.number(),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_category", ["category", "isBuiltIn"])
  .searchIndex("search_templates", {
    searchField: "name",
    filterFields: ["userId", "isBuiltIn", "category"],
  });

export const votesTable = defineTable({
  userId: v.id("users"),
  comparisonGroupId: v.string(),
  winnerId: v.optional(v.id("messages")),
  rating: v.union(
    v.literal("left_better"),
    v.literal("right_better"),
    v.literal("tie"),
    v.literal("both_bad"),
  ),
  votedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_comparison", ["comparisonGroupId"]);

// === PRESENTATIONS ===
export const presentationsTable = defineTable({
  userId: v.id("users"),
  conversationId: v.optional(v.id("conversations")),
  title: v.string(),
  description: v.optional(v.string()),
  status: v.union(
    v.literal("outline_pending"),
    v.literal("outline_generating"),
    v.literal("outline_complete"),
    v.literal("design_generating"),
    v.literal("design_complete"),
    v.literal("slides_generating"),
    v.literal("slides_complete"),
    v.literal("stopped"),
    v.literal("error"),
  ),
  designSystem: v.optional(
    v.object({
      theme: v.string(),
      themeRationale: v.string(),
      primaryColor: v.string(),
      secondaryColor: v.string(),
      accentColor: v.string(),
      backgroundColor: v.string(),
      fontPairings: v.object({
        heading: v.string(),
        body: v.string(),
      }),
      visualStyle: v.string(),
      layoutPrinciples: v.array(v.string()),
      iconStyle: v.string(),
      imageGuidelines: v.string(),
      designInspiration: v.string(),
    }),
  ),
  imageModel: v.string(),
  slideStyle: v.optional(
    v.union(v.literal("wordy"), v.literal("illustrative")),
  ),
  templateId: v.optional(v.id("designTemplates")),
  totalSlides: v.number(),
  generatedSlideCount: v.number(),
  aspectRatio: v.optional(
    v.union(v.literal("16:9"), v.literal("1:1"), v.literal("9:16")),
  ),
  imageStyle: v.optional(v.string()),
  pptxStorageId: v.optional(v.id("_storage")),
  pptxGeneratedAt: v.optional(v.number()),
  pdfStorageId: v.optional(v.id("_storage")),
  pdfGeneratedAt: v.optional(v.number()),
  imagesZipStorageId: v.optional(v.id("_storage")),
  imagesZipGeneratedAt: v.optional(v.number()),
  overallFeedback: v.optional(v.string()),
  currentOutlineVersion: v.optional(v.number()),
  outlineStatus: v.optional(
    v.union(
      v.literal("draft"),
      v.literal("feedback_pending"),
      v.literal("regenerating"),
      v.literal("ready"),
    ),
  ),
  starred: v.optional(v.boolean()),
  pinned: v.optional(v.boolean()),
  embedding: v.optional(v.array(v.float64())),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_conversation", ["conversationId"])
  .index("by_user_status", ["userId", "status"])
  .index("by_user_pinned", ["userId", "pinned"])
  .searchIndex("search_title", {
    searchField: "title",
    filterFields: ["userId"],
  })
  .vectorIndex("by_embedding", {
    vectorField: "embedding",
    dimensions: 1536,
    filterFields: ["userId"],
  });

const slideTypeUnion = v.union(
  v.literal("title"),
  v.literal("section"),
  v.literal("content"),
  v.literal("hook"),
  v.literal("rehook"),
  v.literal("value"),
  v.literal("cta"),
  v.literal("context"),
  v.literal("validation"),
  v.literal("reality"),
  v.literal("emotional"),
  v.literal("reframe"),
  v.literal("affirmation"),
);

export const slidesTable = defineTable({
  presentationId: v.id("presentations"),
  userId: v.id("users"),
  position: v.number(),
  slideType: slideTypeUnion,
  title: v.string(),
  content: v.string(),
  speakerNotes: v.optional(v.string()),
  visualDirection: v.optional(v.string()),
  imageStatus: v.union(
    v.literal("pending"),
    v.literal("generating"),
    v.literal("complete"),
    v.literal("error"),
  ),
  imageStorageId: v.optional(v.id("_storage")),
  imagePrompt: v.optional(v.string()),
  imageError: v.optional(v.string()),
  hasEmbeddedText: v.optional(v.boolean()),
  generationCost: v.optional(v.number()),
  inputTokens: v.optional(v.number()),
  outputTokens: v.optional(v.number()),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_presentation", ["presentationId"])
  .index("by_presentation_position", ["presentationId", "position"])
  .index("by_presentation_type", ["presentationId", "slideType"])
  .index("by_user", ["userId"])
  .index("by_image_status", ["imageStatus"]);

export const outlineItemsTable = defineTable({
  presentationId: v.id("presentations"),
  userId: v.id("users"),
  position: v.number(),
  slideType: slideTypeUnion,
  title: v.string(),
  content: v.string(),
  speakerNotes: v.optional(v.string()),
  visualDirection: v.optional(v.string()),
  feedback: v.optional(v.string()),
  version: v.number(),
  status: v.optional(v.union(v.literal("partial"), v.literal("complete"))),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_presentation", ["presentationId"])
  .index("by_presentation_position", ["presentationId", "position"])
  .index("by_presentation_version", ["presentationId", "version"])
  .index("by_presentation_status", ["presentationId", "status"]);

export const designTemplatesTable = defineTable({
  userId: v.id("users"),
  name: v.string(),
  description: v.optional(v.string()),
  sourceFiles: v.array(
    v.object({
      storageId: v.id("_storage"),
      name: v.string(),
      mimeType: v.string(),
      type: v.union(v.literal("pdf"), v.literal("pptx"), v.literal("image")),
    }),
  ),
  extractedDesign: v.optional(
    v.object({
      colors: v.object({
        primary: v.string(),
        secondary: v.string(),
        accent: v.optional(v.string()),
        background: v.string(),
        text: v.string(),
      }),
      fonts: v.object({
        heading: v.string(),
        body: v.string(),
        fallbackHeading: v.optional(v.string()),
        fallbackBody: v.optional(v.string()),
      }),
      logoGuidelines: v.optional(
        v.object({
          position: v.string(),
          size: v.string(),
          description: v.optional(v.string()),
        }),
      ),
      layoutPatterns: v.array(v.string()),
      visualStyle: v.string(),
      iconStyle: v.optional(v.string()),
      analysisNotes: v.string(),
    }),
  ),
  logoStorageId: v.optional(v.id("_storage")),
  status: v.union(
    v.literal("pending"),
    v.literal("processing"),
    v.literal("complete"),
    v.literal("error"),
  ),
  error: v.optional(v.string()),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_user_status", ["userId", "status"]);

export const presentationSessionsTable = defineTable({
  presentationId: v.id("presentations"),
  userId: v.id("users"),
  sessionCode: v.string(),
  sessionCodeExpiresAt: v.number(),
  isActive: v.boolean(),
  currentSlide: v.number(),
  totalSlides: v.number(),
  timerStartedAt: v.optional(v.number()),
  timerPausedAt: v.optional(v.number()),
  timerElapsed: v.optional(v.number()),
  laserEnabled: v.optional(v.boolean()),
  drawingEnabled: v.optional(v.boolean()),
  lastPresenterPingAt: v.optional(v.number()),
  lastRemotePingAt: v.optional(v.number()),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_session_code", ["sessionCode", "isActive"])
  .index("by_presentation", ["presentationId", "isActive"])
  .index("by_user", ["userId"])
  .index("by_user_active", ["userId", "isActive"]);

// === ACTIVITY ===
export const activityEventsTable = defineTable({
  userId: v.id("users"),
  projectId: v.optional(v.id("projects")),
  eventType: v.string(),
  resourceType: v.optional(
    v.union(
      v.literal("task"),
      v.literal("note"),
      v.literal("file"),
      v.literal("conversation"),
    ),
  ),
  resourceId: v.optional(v.string()),
  metadata: v.optional(v.any()),
  createdAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_project", ["projectId"])
  .index("by_user_created", ["userId", "createdAt"])
  .index("by_project_created", ["projectId", "createdAt"]);

// === CANVAS ===
export const canvasDocumentsTable = defineTable({
  userId: v.id("users"),
  conversationId: v.id("conversations"),
  title: v.string(),
  content: v.string(),
  language: v.optional(v.string()),
  documentType: v.union(v.literal("code"), v.literal("prose")),
  version: v.number(),
  status: v.union(v.literal("active"), v.literal("archived")),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_conversation", ["conversationId"])
  .index("by_user_conversation", ["userId", "conversationId"]);

export const canvasHistoryTable = defineTable({
  documentId: v.id("canvasDocuments"),
  userId: v.id("users"),
  content: v.string(),
  version: v.number(),
  source: v.union(
    v.literal("user_edit"),
    v.literal("llm_diff"),
    v.literal("created"),
  ),
  diff: v.optional(v.string()),
  createdAt: v.number(),
})
  .index("by_document", ["documentId"])
  .index("by_document_version", ["documentId", "version"]);

// === NOTIFICATIONS ===
export const notificationsTable = defineTable({
  userId: v.id("users"),
  type: v.string(),
  title: v.string(),
  message: v.string(),
  data: v.optional(
    v.object({
      conversationId: v.optional(v.id("conversations")),
      joinedUserId: v.optional(v.id("users")),
      joinedUserName: v.optional(v.string()),
    }),
  ),
  read: v.boolean(),
  createdAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_user_unread", ["userId", "read"])
  .index("by_created", ["createdAt"]);

export default defineSchema({
  conversations: conversationsTable,
  conversationParticipants: conversationParticipantsTable,
  conversationTokenUsage: conversationTokenUsageTable,
  messages: messagesTable,
  attachments: attachmentsTable,
  toolCalls: toolCallsTable,
  sourceMetadata: sourceMetadataTable,
  sources: sourcesTable,
  memories: memoriesTable,
  files: filesTable,
  fileChunks: fileChunksTable,
  knowledgeSources: knowledgeSourcesTable,
  knowledgeChunks: knowledgeChunksTable,
  projects: projectsTable,
  projectConversations: projectConversationsTable,
  projectNotes: projectNotesTable,
  projectFiles: projectFilesTable,
  tasks: tasksTable,
  notes: notesTable,
  bookmarks: bookmarksTable,
  snippets: snippetsTable,
  tags: tagsTable,
  bookmarkTags: bookmarkTagsTable,
  snippetTags: snippetTagsTable,
  noteTags: noteTagsTable,
  taskTags: taskTagsTable,
  shares: sharesTable,
  scheduledPrompts: scheduledPromptsTable,
  usageRecords: usageRecordsTable,
  ttsCache: ttsCacheTable,
  templates: templatesTable,
  votes: votesTable,
  presentations: presentationsTable,
  slides: slidesTable,
  outlineItems: outlineItemsTable,
  designTemplates: designTemplatesTable,
  presentationSessions: presentationSessionsTable,
  activityEvents: activityEventsTable,
  canvasDocuments: canvasDocumentsTable,
  canvasHistory: canvasHistoryTable,
  notifications: notificationsTable,
});
