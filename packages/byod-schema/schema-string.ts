// Auto-generated - DO NOT EDIT
export const BUNDLED_SCHEMA_CONTENT =
  '// Auto-generated BYOD schema v8\n// DO NOT EDIT - Self-contained schema for standalone deployment\n\nimport { defineSchema, defineTable } from "convex/server";\nimport { v } from "convex/values";\n\n// === CONVERSATIONS ===\nexport const conversationsTable = defineTable({\n  userId: v.id("users"),\n  title: v.string(),\n  model: v.string(),\n  pinned: v.boolean(),\n  archived: v.boolean(),\n  starred: v.boolean(),\n  systemPrompt: v.optional(v.string()),\n  projectId: v.optional(v.id("projects")),\n  lastMemoryExtractionAt: v.optional(v.number()),\n  memoryExtractionMessageCount: v.optional(v.number()),\n  // Phase 2B: Memory caching\n  cachedMemoryIds: v.optional(v.array(v.id("memories"))),\n  lastMemoryFetchAt: v.optional(v.number()),\n  // Incremental extraction cursor\n  lastExtractedMessageId: v.optional(v.id("messages")),\n  // Token usage tracking\n  tokenUsage: v.optional(\n    v.object({\n      systemTokens: v.number(),\n      messagesTokens: v.number(),\n      memoriesTokens: v.number(),\n      totalTokens: v.number(),\n      contextLimit: v.number(),\n      lastCalculatedAt: v.number(),\n    }),\n  ),\n  messageCount: v.optional(v.number()),\n  lastMessageAt: v.number(),\n  // Branching support\n  parentConversationId: v.optional(v.id("conversations")),\n  parentMessageId: v.optional(v.id("messages")),\n  // Collaborative conversations (multi-user)\n  isCollaborative: v.optional(v.boolean()),\n  // Incognito mode (ephemeral conversations)\n  isIncognito: v.optional(v.boolean()),\n  incognitoSettings: v.optional(\n    v.object({\n      enableReadTools: v.boolean(),\n      applyCustomInstructions: v.boolean(),\n      inactivityTimeoutMinutes: v.optional(v.number()),\n      scheduledDeletionId: v.optional(v.id("_scheduled_functions")),\n      lastActivityAt: v.number(),\n    }),\n  ),\n  // Presentation mode (slides feature conversations)\n  isPresentation: v.optional(v.boolean()),\n  // Enable web search grounding for presentations\n  enableGrounding: v.optional(v.boolean()),\n  // Presentation metadata\n  slideStyle: v.optional(\n    v.union(v.literal("wordy"), v.literal("illustrative")),\n  ),\n  imageStyle: v.optional(v.string()),\n  aspectRatio: v.optional(\n    v.union(v.literal("16:9"), v.literal("1:1"), v.literal("9:16")),\n  ),\n  templateId: v.optional(v.id("templates")),\n  // Model recommendation (cost optimization & decision guidance)\n  modelRecommendation: v.optional(\n    v.object({\n      suggestedModelId: v.string(),\n      currentModelId: v.string(),\n      reasoning: v.string(),\n      estimatedSavings: v.object({\n        costReduction: v.string(),\n        percentSaved: v.number(),\n      }),\n      createdAt: v.number(),\n      dismissed: v.boolean(),\n    }),\n  ),\n  // Document mode (Canvas)\n  mode: v.optional(v.union(v.literal("document"), v.literal("normal"))),\n  modeActivatedAt: v.optional(v.number()),\n  // Cached system prompt (built in background on creation/input changes)\n  cachedSystemPrompt: v.optional(v.string()),\n  promptInputHash: v.optional(v.string()),\n  promptBuiltAt: v.optional(v.number()),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_user_pinned", ["userId", "pinned"])\n  .index("by_projectId", ["projectId"])\n  .index("by_parent_conversation", ["parentConversationId"])\n  .searchIndex("search_title", {\n    searchField: "title",\n    filterFields: ["userId", "archived"],\n  });\n\nexport const conversationParticipantsTable = defineTable({\n  conversationId: v.id("conversations"),\n  userId: v.id("users"),\n  role: v.union(v.literal("owner"), v.literal("collaborator")),\n  joinedAt: v.number(),\n  invitedBy: v.optional(v.id("users")),\n  sourceShareId: v.optional(v.string()),\n})\n  .index("by_conversation", ["conversationId"])\n  .index("by_user", ["userId"])\n  .index("by_user_conversation", ["userId", "conversationId"]);\n\nexport const conversationTokenUsageTable = defineTable({\n  conversationId: v.id("conversations"),\n  model: v.string(),\n  totalTokens: v.number(),\n  inputTokens: v.number(),\n  outputTokens: v.number(),\n  reasoningTokens: v.optional(v.number()),\n  messageCount: v.number(),\n  lastUpdatedAt: v.number(),\n  createdAt: v.number(),\n})\n  .index("by_conversation", ["conversationId"])\n  .index("by_conversation_model", ["conversationId", "model"]);\n\n// === MESSAGES ===\nexport const messagesTable = defineTable({\n  conversationId: v.id("conversations"),\n  userId: v.optional(v.id("users")),\n  role: v.union(v.literal("user"), v.literal("assistant"), v.literal("system")),\n  content: v.string(),\n  partialContent: v.optional(v.string()),\n  status: v.union(\n    v.literal("pending"),\n    v.literal("generating"),\n    v.literal("complete"),\n    v.literal("stopped"),\n    v.literal("error"),\n  ),\n  model: v.optional(v.string()),\n  inputTokens: v.optional(v.number()),\n  outputTokens: v.optional(v.number()),\n  cost: v.optional(v.number()),\n  // Reasoning/thinking support\n  reasoning: v.optional(v.string()),\n  partialReasoning: v.optional(v.string()),\n  reasoningTokens: v.optional(v.number()),\n  thinkingStartedAt: v.optional(v.number()),\n  thinkingCompletedAt: v.optional(v.number()),\n  error: v.optional(v.string()),\n  embedding: v.optional(v.array(v.float64())),\n  // Provider specific metadata\n  providerMetadata: v.optional(v.any()),\n  // Branching support\n  parentMessageId: v.optional(v.id("messages")),\n  branchLabel: v.optional(v.string()),\n  branchIndex: v.optional(v.number()),\n  // Comparison support\n  comparisonGroupId: v.optional(v.string()),\n  consolidatedMessageId: v.optional(v.id("messages")),\n  isConsolidation: v.optional(v.boolean()),\n  votes: v.optional(\n    v.object({\n      rating: v.union(\n        v.literal("left_better"),\n        v.literal("right_better"),\n        v.literal("tie"),\n        v.literal("both_bad"),\n      ),\n      isWinner: v.boolean(),\n      votedAt: v.number(),\n    }),\n  ),\n  generationStartedAt: v.optional(v.number()),\n  generationCompletedAt: v.optional(v.number()),\n  // Performance metrics\n  apiCallStartedAt: v.optional(v.number()), // When LLM API call made (for true TTFT)\n  firstTokenAt: v.optional(v.number()),\n  tokensPerSecond: v.optional(v.number()),\n  // Memory extraction tracking\n  memoryExtracted: v.optional(v.boolean()),\n  memoryExtractedAt: v.optional(v.number()),\n  // DEPRECATED: Source citations migrated to normalized tables\n  sources: v.optional(\n    v.array(\n      v.object({\n        id: v.string(),\n        title: v.string(),\n        url: v.string(),\n        publishedDate: v.optional(v.string()),\n        snippet: v.optional(v.string()),\n      }),\n    ),\n  ),\n  partialSources: v.optional(\n    v.array(\n      v.object({\n        id: v.string(),\n        title: v.string(),\n        url: v.string(),\n        publishedDate: v.optional(v.string()),\n        snippet: v.optional(v.string()),\n      }),\n    ),\n  ),\n  sourceMetadata: v.optional(\n    v.array(\n      v.object({\n        sourceId: v.string(),\n        ogTitle: v.optional(v.string()),\n        ogDescription: v.optional(v.string()),\n        ogImage: v.optional(v.string()),\n        favicon: v.optional(v.string()),\n        domain: v.string(),\n        fetchedAt: v.optional(v.number()),\n        error: v.optional(v.string()),\n      }),\n    ),\n  ),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_conversation", ["conversationId"])\n  .index("by_user", ["userId"])\n  .index("by_status", ["status"])\n  .index("by_parent", ["parentMessageId"])\n  .index("by_comparison_group", ["comparisonGroupId"])\n  .index("by_consolidated_message", ["consolidatedMessageId"])\n  .index("by_conversation_created", ["conversationId", "createdAt"])\n  .index("by_conversation_role", ["conversationId", "role"])\n  .vectorIndex("by_embedding", {\n    vectorField: "embedding",\n    dimensions: 1536,\n    filterFields: ["conversationId", "userId"],\n  })\n  .searchIndex("search_content", {\n    searchField: "content",\n    filterFields: ["conversationId", "userId", "role"],\n  });\n\nexport const attachmentsTable = defineTable({\n  messageId: v.id("messages"),\n  conversationId: v.id("conversations"),\n  userId: v.id("users"),\n  type: v.union(v.literal("image"), v.literal("file"), v.literal("audio")),\n  name: v.string(),\n  storageId: v.id("_storage"),\n  mimeType: v.string(),\n  size: v.number(),\n  metadata: v.optional(\n    v.object({\n      width: v.optional(v.number()),\n      height: v.optional(v.number()),\n      duration: v.optional(v.number()),\n      prompt: v.optional(v.string()),\n      model: v.optional(v.string()),\n      generationTime: v.optional(v.number()),\n    }),\n  ),\n  createdAt: v.number(),\n})\n  .index("by_message", ["messageId"])\n  .index("by_conversation", ["conversationId"])\n  .index("by_user", ["userId"])\n  .index("by_storage", ["storageId"]);\n\nexport const toolCallsTable = defineTable({\n  messageId: v.id("messages"),\n  conversationId: v.id("conversations"),\n  userId: v.id("users"),\n  toolCallId: v.string(),\n  toolName: v.string(),\n  args: v.any(),\n  result: v.optional(v.any()),\n  textPosition: v.optional(v.number()),\n  isPartial: v.boolean(),\n  timestamp: v.number(),\n  createdAt: v.number(),\n})\n  .index("by_message", ["messageId"])\n  .index("by_conversation", ["conversationId"])\n  .index("by_user", ["userId"])\n  .index("by_message_partial", ["messageId", "isPartial"]);\n\nexport const sourceMetadataTable = defineTable({\n  urlHash: v.string(),\n  url: v.string(),\n  title: v.optional(v.string()),\n  description: v.optional(v.string()),\n  ogImage: v.optional(v.string()),\n  favicon: v.optional(v.string()),\n  siteName: v.optional(v.string()),\n  enriched: v.boolean(),\n  enrichedAt: v.optional(v.number()),\n  enrichmentError: v.optional(v.string()),\n  firstSeenAt: v.number(),\n  lastAccessedAt: v.number(),\n  accessCount: v.number(),\n})\n  .index("by_urlHash", ["urlHash"])\n  .index("by_url", ["url"]);\n\nexport const sourcesTable = defineTable({\n  messageId: v.id("messages"),\n  conversationId: v.id("conversations"),\n  userId: v.id("users"),\n  position: v.number(),\n  provider: v.string(),\n  title: v.optional(v.string()),\n  snippet: v.optional(v.string()),\n  urlHash: v.string(),\n  url: v.string(),\n  isPartial: v.boolean(),\n  createdAt: v.number(),\n})\n  .index("by_message", ["messageId"])\n  .index("by_conversation", ["conversationId", "createdAt"])\n  .index("by_urlHash", ["urlHash"])\n  .index("by_user", ["userId", "createdAt"]);\n\n// === MEMORIES ===\nexport const memoriesTable = defineTable({\n  userId: v.id("users"),\n  content: v.string(),\n  embedding: v.array(v.number()),\n  conversationId: v.optional(v.id("conversations")),\n  sourceMessageId: v.optional(v.id("messages")),\n  sourceMessageIds: v.optional(v.array(v.id("messages"))),\n  metadata: v.object({\n    category: v.string(),\n    importance: v.optional(v.number()),\n    reasoning: v.optional(v.string()),\n    extractedAt: v.optional(v.number()),\n    sourceConversationId: v.optional(v.id("conversations")),\n    confidence: v.optional(v.number()),\n    verifiedBy: v.optional(\n      v.union(\n        v.literal("auto"),\n        v.literal("manual"),\n        v.literal("consolidated"),\n      ),\n    ),\n    expiresAt: v.optional(v.number()),\n    version: v.optional(v.number()),\n    supersededBy: v.optional(v.id("memories")),\n    expirationHint: v.optional(\n      v.union(\n        v.literal("contextual"),\n        v.literal("preference"),\n        v.literal("deadline"),\n        v.literal("temporary"),\n      ),\n    ),\n  }),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_user_category", ["userId", "metadata.category"])\n  .index("by_importance", ["userId", "metadata.importance"])\n  .index("by_conversation", ["conversationId"])\n  .vectorIndex("by_embedding", {\n    vectorField: "embedding",\n    dimensions: 1536,\n    filterFields: ["userId"],\n  })\n  .searchIndex("search_content", {\n    searchField: "content",\n    filterFields: ["userId", "metadata.category"],\n  });\n\n// === FILES ===\nexport const filesTable = defineTable({\n  userId: v.id("users"),\n  conversationId: v.optional(v.id("conversations")),\n  storageId: v.id("_storage"),\n  name: v.string(),\n  mimeType: v.string(),\n  size: v.number(),\n  chunkCount: v.optional(v.number()),\n  embeddingStatus: v.optional(\n    v.union(\n      v.literal("pending"),\n      v.literal("processing"),\n      v.literal("completed"),\n      v.literal("failed"),\n    ),\n  ),\n  embeddingError: v.optional(v.string()),\n  processedAt: v.optional(v.number()),\n  createdAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_conversation", ["conversationId"]);\n\nexport const fileChunksTable = defineTable({\n  fileId: v.id("files"),\n  userId: v.id("users"),\n  projectId: v.optional(v.id("projects")),\n  chunkIndex: v.number(),\n  content: v.string(),\n  startPage: v.optional(v.number()),\n  endPage: v.optional(v.number()),\n  section: v.optional(v.string()),\n  charOffset: v.number(),\n  tokenCount: v.number(),\n  embedding: v.array(v.float64()),\n  createdAt: v.number(),\n})\n  .index("by_file", ["fileId"])\n  .index("by_user", ["userId"])\n  .index("by_project", ["projectId"])\n  .vectorIndex("by_embedding", {\n    vectorField: "embedding",\n    dimensions: 1536,\n    filterFields: ["userId", "projectId"],\n  });\n\nexport const knowledgeSourcesTable = defineTable({\n  userId: v.id("users"),\n  projectId: v.optional(v.id("projects")),\n  type: v.union(\n    v.literal("file"),\n    v.literal("text"),\n    v.literal("web"),\n    v.literal("youtube"),\n  ),\n  title: v.string(),\n  description: v.optional(v.string()),\n  storageId: v.optional(v.id("_storage")),\n  url: v.optional(v.string()),\n  rawContent: v.optional(v.string()),\n  videoMetadata: v.optional(\n    v.object({\n      videoId: v.string(),\n      duration: v.optional(v.number()),\n      channel: v.optional(v.string()),\n      thumbnailUrl: v.optional(v.string()),\n    }),\n  ),\n  mimeType: v.optional(v.string()),\n  size: v.optional(v.number()),\n  status: v.union(\n    v.literal("pending"),\n    v.literal("processing"),\n    v.literal("completed"),\n    v.literal("failed"),\n  ),\n  error: v.optional(v.string()),\n  chunkCount: v.optional(v.number()),\n  processedAt: v.optional(v.number()),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_project", ["projectId"])\n  .index("by_user_type", ["userId", "type"])\n  .index("by_user_project", ["userId", "projectId"])\n  .index("by_status", ["status"]);\n\nexport const knowledgeChunksTable = defineTable({\n  sourceId: v.id("knowledgeSources"),\n  userId: v.id("users"),\n  projectId: v.optional(v.id("projects")),\n  content: v.string(),\n  chunkIndex: v.number(),\n  charOffset: v.number(),\n  tokenCount: v.number(),\n  startTime: v.optional(v.string()),\n  endTime: v.optional(v.string()),\n  pageNumber: v.optional(v.number()),\n  embedding: v.array(v.float64()),\n  createdAt: v.number(),\n})\n  .index("by_source", ["sourceId"])\n  .index("by_user", ["userId"])\n  .index("by_project", ["projectId"])\n  .vectorIndex("by_embedding", {\n    vectorField: "embedding",\n    dimensions: 1536,\n    filterFields: ["userId", "projectId"],\n  });\n\n// === PROJECTS ===\nexport const projectsTable = defineTable({\n  userId: v.id("users"),\n  name: v.string(),\n  description: v.optional(v.string()),\n  systemPrompt: v.optional(v.string()),\n  isTemplate: v.optional(v.boolean()),\n  createdFrom: v.optional(v.id("projects")),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_userId_isTemplate", ["userId", "isTemplate"]);\n\nexport const projectConversationsTable = defineTable({\n  projectId: v.id("projects"),\n  conversationId: v.id("conversations"),\n  addedAt: v.number(),\n  addedBy: v.id("users"),\n})\n  .index("by_project", ["projectId"])\n  .index("by_conversation", ["conversationId"])\n  .index("by_project_conversation", ["projectId", "conversationId"]);\n\nexport const projectNotesTable = defineTable({\n  projectId: v.id("projects"),\n  noteId: v.id("notes"),\n  userId: v.id("users"),\n  addedAt: v.number(),\n})\n  .index("by_project", ["projectId"])\n  .index("by_note", ["noteId"])\n  .index("by_user_project", ["userId", "projectId"])\n  .index("by_project_note", ["projectId", "noteId"]);\n\nexport const projectFilesTable = defineTable({\n  projectId: v.id("projects"),\n  fileId: v.id("files"),\n  userId: v.id("users"),\n  addedAt: v.number(),\n})\n  .index("by_project", ["projectId"])\n  .index("by_file", ["fileId"])\n  .index("by_user_project", ["userId", "projectId"])\n  .index("by_project_file", ["projectId", "fileId"]);\n\n// === TASKS ===\nexport const tasksTable = defineTable({\n  userId: v.id("users"),\n  title: v.string(),\n  description: v.optional(v.string()),\n  status: v.union(\n    v.literal("suggested"),\n    v.literal("confirmed"),\n    v.literal("in_progress"),\n    v.literal("completed"),\n    v.literal("cancelled"),\n  ),\n  deadline: v.optional(v.number()),\n  deadlineSource: v.optional(v.string()),\n  urgency: v.optional(\n    v.union(\n      v.literal("low"),\n      v.literal("medium"),\n      v.literal("high"),\n      v.literal("urgent"),\n    ),\n  ),\n  tags: v.optional(v.array(v.string())),\n  sourceType: v.optional(\n    v.union(\n      v.literal("transcript"),\n      v.literal("conversation"),\n      v.literal("manual"),\n      v.literal("file"),\n    ),\n  ),\n  sourceId: v.optional(v.string()),\n  sourceContext: v.optional(\n    v.object({\n      snippet: v.optional(v.string()),\n      timestampSeconds: v.optional(v.number()),\n      confidence: v.optional(v.number()),\n    }),\n  ),\n  projectId: v.optional(v.id("projects")),\n  priority: v.optional(v.number()),\n  position: v.optional(v.number()),\n  completedAt: v.optional(v.number()),\n  embedding: v.optional(v.array(v.float64())),\n  embeddingStatus: v.optional(\n    v.union(\n      v.literal("pending"),\n      v.literal("processing"),\n      v.literal("completed"),\n      v.literal("failed"),\n    ),\n  ),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_user_status", ["userId", "status"])\n  .index("by_user_deadline", ["userId", "deadline"])\n  .index("by_project", ["projectId"])\n  .index("by_user_project", ["userId", "projectId"])\n  .searchIndex("search_title", {\n    searchField: "title",\n    filterFields: ["userId", "status", "projectId"],\n  })\n  .vectorIndex("by_embedding", {\n    vectorField: "embedding",\n    dimensions: 1536,\n    filterFields: ["userId", "projectId"],\n  });\n\n// === NOTES ===\nexport const notesTable = defineTable({\n  userId: v.id("users"),\n  title: v.string(),\n  content: v.string(),\n  htmlContent: v.optional(v.string()),\n  sourceMessageId: v.optional(v.id("messages")),\n  sourceConversationId: v.optional(v.id("conversations")),\n  sourceSelectionText: v.optional(v.string()),\n  projectId: v.optional(v.id("projects")),\n  tags: v.optional(v.array(v.string())),\n  suggestedTags: v.optional(v.array(v.string())),\n  isPinned: v.boolean(),\n  shareId: v.optional(v.string()),\n  isPublic: v.optional(v.boolean()),\n  sharePassword: v.optional(v.string()),\n  shareExpiresAt: v.optional(v.number()),\n  shareCreatedAt: v.optional(v.number()),\n  shareViewCount: v.optional(v.number()),\n  embedding: v.optional(v.array(v.float64())),\n  embeddingStatus: v.optional(\n    v.union(\n      v.literal("pending"),\n      v.literal("processing"),\n      v.literal("completed"),\n      v.literal("failed"),\n    ),\n  ),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_user_updated", ["userId", "updatedAt"])\n  .index("by_source_message", ["sourceMessageId"])\n  .index("by_share_id", ["shareId"])\n  .index("by_projectId", ["projectId"])\n  .searchIndex("search_notes", {\n    searchField: "content",\n    filterFields: ["userId"],\n  })\n  .vectorIndex("by_embedding", {\n    vectorField: "embedding",\n    dimensions: 1536,\n    filterFields: ["userId", "projectId"],\n  });\n\n// === BOOKMARKS ===\nexport const bookmarksTable = defineTable({\n  userId: v.id("users"),\n  messageId: v.id("messages"),\n  conversationId: v.id("conversations"),\n  note: v.optional(v.string()),\n  tags: v.optional(v.array(v.string())),\n  createdAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_message", ["messageId"])\n  .index("by_conversation", ["conversationId"])\n  .index("by_user_created", ["userId", "createdAt"]);\n\nexport const snippetsTable = defineTable({\n  userId: v.id("users"),\n  text: v.string(),\n  sourceMessageId: v.id("messages"),\n  sourceConversationId: v.id("conversations"),\n  note: v.optional(v.string()),\n  tags: v.optional(v.array(v.string())),\n  createdAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_message", ["sourceMessageId"])\n  .index("by_conversation", ["sourceConversationId"])\n  .searchIndex("search_text", {\n    searchField: "text",\n    filterFields: ["userId"],\n  });\n\n// === TAGS ===\nexport const tagsTable = defineTable({\n  slug: v.string(),\n  displayName: v.string(),\n  userId: v.optional(v.id("users")),\n  scope: v.union(v.literal("user"), v.literal("global")),\n  parentId: v.optional(v.id("tags")),\n  path: v.string(),\n  depth: v.number(),\n  usageCount: v.number(),\n  color: v.optional(v.string()),\n  description: v.optional(v.string()),\n  embedding: v.optional(v.array(v.float64())),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_user_slug", ["userId", "slug"])\n  .index("by_user_usage", ["userId", "usageCount"])\n  .index("by_scope", ["scope"])\n  .index("by_parent", ["parentId"])\n  .index("by_user_path", ["userId", "path"]);\n\nexport const bookmarkTagsTable = defineTable({\n  bookmarkId: v.id("bookmarks"),\n  tagId: v.id("tags"),\n  userId: v.id("users"),\n  createdAt: v.number(),\n})\n  .index("by_bookmark", ["bookmarkId"])\n  .index("by_tag", ["tagId"])\n  .index("by_user", ["userId"])\n  .index("by_bookmark_tag", ["bookmarkId", "tagId"]);\n\nexport const snippetTagsTable = defineTable({\n  snippetId: v.id("snippets"),\n  tagId: v.id("tags"),\n  userId: v.id("users"),\n  createdAt: v.number(),\n})\n  .index("by_snippet", ["snippetId"])\n  .index("by_tag", ["tagId"])\n  .index("by_user", ["userId"])\n  .index("by_snippet_tag", ["snippetId", "tagId"]);\n\nexport const noteTagsTable = defineTable({\n  noteId: v.id("notes"),\n  tagId: v.id("tags"),\n  userId: v.id("users"),\n  createdAt: v.number(),\n})\n  .index("by_note", ["noteId"])\n  .index("by_tag", ["tagId"])\n  .index("by_user", ["userId"])\n  .index("by_note_tag", ["noteId", "tagId"]);\n\nexport const taskTagsTable = defineTable({\n  taskId: v.id("tasks"),\n  tagId: v.id("tags"),\n  userId: v.id("users"),\n  addedAt: v.number(),\n})\n  .index("by_task", ["taskId"])\n  .index("by_tag", ["tagId"])\n  .index("by_user", ["userId"])\n  .index("by_task_tag", ["taskId", "tagId"]);\n\n// === SHARES ===\nexport const sharesTable = defineTable({\n  userId: v.id("users"),\n  conversationId: v.id("conversations"),\n  shareId: v.string(),\n  title: v.string(),\n  expiresAt: v.optional(v.number()),\n  isPublic: v.boolean(),\n  isActive: v.boolean(),\n  password: v.optional(v.string()),\n  anonymizeUsernames: v.optional(v.boolean()),\n  viewCount: v.number(),\n  createdAt: v.number(),\n})\n  .index("by_share_id", ["shareId"])\n  .index("by_user", ["userId"])\n  .index("by_conversation", ["conversationId"]);\n\nexport const scheduledPromptsTable = defineTable({\n  userId: v.id("users"),\n  prompt: v.string(),\n  schedule: v.object({\n    type: v.union(\n      v.literal("daily"),\n      v.literal("weekly"),\n      v.literal("monthly"),\n    ),\n    time: v.string(),\n    dayOfWeek: v.optional(v.number()),\n    dayOfMonth: v.optional(v.number()),\n    timezone: v.string(),\n  }),\n  model: v.string(),\n  projectId: v.optional(v.id("projects")),\n  isActive: v.boolean(),\n  lastRunAt: v.optional(v.number()),\n  nextRunAt: v.number(),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_next_run", ["nextRunAt", "isActive"]);\n\n// === USAGE ===\nexport const usageRecordsTable = defineTable({\n  userId: v.id("users"),\n  date: v.string(),\n  model: v.string(),\n  conversationId: v.optional(v.id("conversations")),\n  presentationId: v.optional(v.id("presentations")),\n  feature: v.optional(\n    v.union(\n      v.literal("chat"),\n      v.literal("slides"),\n      v.literal("notes"),\n      v.literal("tasks"),\n      v.literal("files"),\n      v.literal("memory"),\n      v.literal("smart_assistant"),\n    ),\n  ),\n  operationType: v.optional(\n    v.union(\n      v.literal("text"),\n      v.literal("tts"),\n      v.literal("stt"),\n      v.literal("image"),\n      v.literal("embedding"),\n    ),\n  ),\n  inputTokens: v.number(),\n  outputTokens: v.number(),\n  reasoningTokens: v.optional(v.number()),\n  cost: v.number(),\n  messageCount: v.number(),\n  warningsSent: v.optional(v.array(v.string())),\n  isByok: v.optional(v.boolean()),\n})\n  .index("by_user_date", ["userId", "date"])\n  .index("by_user", ["userId"])\n  .index("by_user_date_model", ["userId", "date", "model"])\n  .index("by_conversation", ["conversationId"])\n  .index("by_presentation", ["presentationId"])\n  .index("by_user_feature", ["userId", "feature"]);\n\nexport const ttsCacheTable = defineTable({\n  hash: v.string(),\n  storageId: v.id("_storage"),\n  text: v.string(),\n  voice: v.string(),\n  speed: v.number(),\n  format: v.string(),\n  createdAt: v.number(),\n  lastAccessedAt: v.number(),\n}).index("by_hash", ["hash"]);\n\n// === TEMPLATES ===\nexport const templatesTable = defineTable({\n  userId: v.optional(v.id("users")),\n  name: v.string(),\n  prompt: v.string(),\n  description: v.optional(v.string()),\n  category: v.string(),\n  isBuiltIn: v.boolean(),\n  isPublic: v.boolean(),\n  usageCount: v.number(),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_category", ["category", "isBuiltIn"])\n  .searchIndex("search_templates", {\n    searchField: "name",\n    filterFields: ["userId", "isBuiltIn", "category"],\n  });\n\nexport const votesTable = defineTable({\n  userId: v.id("users"),\n  comparisonGroupId: v.string(),\n  winnerId: v.optional(v.id("messages")),\n  rating: v.union(\n    v.literal("left_better"),\n    v.literal("right_better"),\n    v.literal("tie"),\n    v.literal("both_bad"),\n  ),\n  votedAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_comparison", ["comparisonGroupId"]);\n\n// === PRESENTATIONS ===\nexport const presentationsTable = defineTable({\n  userId: v.id("users"),\n  conversationId: v.optional(v.id("conversations")),\n  title: v.string(),\n  description: v.optional(v.string()),\n  status: v.union(\n    v.literal("outline_pending"),\n    v.literal("outline_generating"),\n    v.literal("outline_complete"),\n    v.literal("design_generating"),\n    v.literal("design_complete"),\n    v.literal("slides_generating"),\n    v.literal("slides_complete"),\n    v.literal("stopped"),\n    v.literal("error"),\n  ),\n  designSystem: v.optional(\n    v.object({\n      theme: v.string(),\n      themeRationale: v.string(),\n      primaryColor: v.string(),\n      secondaryColor: v.string(),\n      accentColor: v.string(),\n      backgroundColor: v.string(),\n      fontPairings: v.object({\n        heading: v.string(),\n        body: v.string(),\n      }),\n      visualStyle: v.string(),\n      layoutPrinciples: v.array(v.string()),\n      iconStyle: v.string(),\n      imageGuidelines: v.string(),\n      designInspiration: v.string(),\n    }),\n  ),\n  imageModel: v.string(),\n  slideStyle: v.optional(\n    v.union(v.literal("wordy"), v.literal("illustrative")),\n  ),\n  templateId: v.optional(v.id("designTemplates")),\n  totalSlides: v.number(),\n  generatedSlideCount: v.number(),\n  aspectRatio: v.optional(\n    v.union(v.literal("16:9"), v.literal("1:1"), v.literal("9:16")),\n  ),\n  imageStyle: v.optional(v.string()),\n  pptxStorageId: v.optional(v.id("_storage")),\n  pptxGeneratedAt: v.optional(v.number()),\n  pdfStorageId: v.optional(v.id("_storage")),\n  pdfGeneratedAt: v.optional(v.number()),\n  imagesZipStorageId: v.optional(v.id("_storage")),\n  imagesZipGeneratedAt: v.optional(v.number()),\n  overallFeedback: v.optional(v.string()),\n  currentOutlineVersion: v.optional(v.number()),\n  outlineStatus: v.optional(\n    v.union(\n      v.literal("draft"),\n      v.literal("feedback_pending"),\n      v.literal("regenerating"),\n      v.literal("ready"),\n    ),\n  ),\n  starred: v.optional(v.boolean()),\n  pinned: v.optional(v.boolean()),\n  embedding: v.optional(v.array(v.float64())),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_conversation", ["conversationId"])\n  .index("by_user_status", ["userId", "status"])\n  .index("by_user_pinned", ["userId", "pinned"])\n  .searchIndex("search_title", {\n    searchField: "title",\n    filterFields: ["userId"],\n  })\n  .vectorIndex("by_embedding", {\n    vectorField: "embedding",\n    dimensions: 1536,\n    filterFields: ["userId"],\n  });\n\nconst slideTypeUnion = v.union(\n  v.literal("title"),\n  v.literal("section"),\n  v.literal("content"),\n  v.literal("hook"),\n  v.literal("rehook"),\n  v.literal("value"),\n  v.literal("cta"),\n  v.literal("context"),\n  v.literal("validation"),\n  v.literal("reality"),\n  v.literal("emotional"),\n  v.literal("reframe"),\n  v.literal("affirmation"),\n);\n\nexport const slidesTable = defineTable({\n  presentationId: v.id("presentations"),\n  userId: v.id("users"),\n  position: v.number(),\n  slideType: slideTypeUnion,\n  title: v.string(),\n  content: v.string(),\n  speakerNotes: v.optional(v.string()),\n  visualDirection: v.optional(v.string()),\n  imageStatus: v.union(\n    v.literal("pending"),\n    v.literal("generating"),\n    v.literal("complete"),\n    v.literal("error"),\n  ),\n  imageStorageId: v.optional(v.id("_storage")),\n  imagePrompt: v.optional(v.string()),\n  imageError: v.optional(v.string()),\n  hasEmbeddedText: v.optional(v.boolean()),\n  generationCost: v.optional(v.number()),\n  inputTokens: v.optional(v.number()),\n  outputTokens: v.optional(v.number()),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_presentation", ["presentationId"])\n  .index("by_presentation_position", ["presentationId", "position"])\n  .index("by_presentation_type", ["presentationId", "slideType"])\n  .index("by_user", ["userId"])\n  .index("by_image_status", ["imageStatus"]);\n\nexport const outlineItemsTable = defineTable({\n  presentationId: v.id("presentations"),\n  userId: v.id("users"),\n  position: v.number(),\n  slideType: slideTypeUnion,\n  title: v.string(),\n  content: v.string(),\n  speakerNotes: v.optional(v.string()),\n  visualDirection: v.optional(v.string()),\n  feedback: v.optional(v.string()),\n  version: v.number(),\n  status: v.optional(v.union(v.literal("partial"), v.literal("complete"))),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_presentation", ["presentationId"])\n  .index("by_presentation_position", ["presentationId", "position"])\n  .index("by_presentation_version", ["presentationId", "version"])\n  .index("by_presentation_status", ["presentationId", "status"]);\n\nexport const designTemplatesTable = defineTable({\n  userId: v.id("users"),\n  name: v.string(),\n  description: v.optional(v.string()),\n  sourceFiles: v.array(\n    v.object({\n      storageId: v.id("_storage"),\n      name: v.string(),\n      mimeType: v.string(),\n      type: v.union(v.literal("pdf"), v.literal("pptx"), v.literal("image")),\n    }),\n  ),\n  extractedDesign: v.optional(\n    v.object({\n      colors: v.object({\n        primary: v.string(),\n        secondary: v.string(),\n        accent: v.optional(v.string()),\n        background: v.string(),\n        text: v.string(),\n      }),\n      fonts: v.object({\n        heading: v.string(),\n        body: v.string(),\n        fallbackHeading: v.optional(v.string()),\n        fallbackBody: v.optional(v.string()),\n      }),\n      logoGuidelines: v.optional(\n        v.object({\n          position: v.string(),\n          size: v.string(),\n          description: v.optional(v.string()),\n        }),\n      ),\n      layoutPatterns: v.array(v.string()),\n      visualStyle: v.string(),\n      iconStyle: v.optional(v.string()),\n      analysisNotes: v.string(),\n    }),\n  ),\n  logoStorageId: v.optional(v.id("_storage")),\n  status: v.union(\n    v.literal("pending"),\n    v.literal("processing"),\n    v.literal("complete"),\n    v.literal("error"),\n  ),\n  error: v.optional(v.string()),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_user_status", ["userId", "status"]);\n\nexport const presentationSessionsTable = defineTable({\n  presentationId: v.id("presentations"),\n  userId: v.id("users"),\n  sessionCode: v.string(),\n  sessionCodeExpiresAt: v.number(),\n  isActive: v.boolean(),\n  currentSlide: v.number(),\n  totalSlides: v.number(),\n  timerStartedAt: v.optional(v.number()),\n  timerPausedAt: v.optional(v.number()),\n  timerElapsed: v.optional(v.number()),\n  laserEnabled: v.optional(v.boolean()),\n  drawingEnabled: v.optional(v.boolean()),\n  lastPresenterPingAt: v.optional(v.number()),\n  lastRemotePingAt: v.optional(v.number()),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_session_code", ["sessionCode", "isActive"])\n  .index("by_presentation", ["presentationId", "isActive"])\n  .index("by_user", ["userId"])\n  .index("by_user_active", ["userId", "isActive"]);\n\n// === ACTIVITY ===\nexport const activityEventsTable = defineTable({\n  userId: v.id("users"),\n  projectId: v.optional(v.id("projects")),\n  eventType: v.string(),\n  resourceType: v.optional(\n    v.union(\n      v.literal("task"),\n      v.literal("note"),\n      v.literal("file"),\n      v.literal("conversation"),\n    ),\n  ),\n  resourceId: v.optional(v.string()),\n  metadata: v.optional(v.any()),\n  createdAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_project", ["projectId"])\n  .index("by_user_created", ["userId", "createdAt"])\n  .index("by_project_created", ["projectId", "createdAt"]);\n\n// === CANVAS ===\nexport const canvasDocumentsTable = defineTable({\n  userId: v.id("users"),\n  conversationId: v.id("conversations"),\n  title: v.string(),\n  content: v.string(),\n  language: v.optional(v.string()),\n  documentType: v.union(v.literal("code"), v.literal("prose")),\n  version: v.number(),\n  status: v.union(v.literal("active"), v.literal("archived")),\n  createdAt: v.number(),\n  updatedAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_conversation", ["conversationId"])\n  .index("by_user_conversation", ["userId", "conversationId"]);\n\nexport const canvasHistoryTable = defineTable({\n  documentId: v.id("canvasDocuments"),\n  userId: v.id("users"),\n  content: v.string(),\n  version: v.number(),\n  source: v.union(\n    v.literal("user_edit"),\n    v.literal("llm_diff"),\n    v.literal("created"),\n  ),\n  diff: v.optional(v.string()),\n  createdAt: v.number(),\n})\n  .index("by_document", ["documentId"])\n  .index("by_document_version", ["documentId", "version"]);\n\n// === NOTIFICATIONS ===\nexport const notificationsTable = defineTable({\n  userId: v.id("users"),\n  type: v.string(),\n  title: v.string(),\n  message: v.string(),\n  data: v.optional(\n    v.object({\n      conversationId: v.optional(v.id("conversations")),\n      joinedUserId: v.optional(v.id("users")),\n      joinedUserName: v.optional(v.string()),\n    }),\n  ),\n  read: v.boolean(),\n  createdAt: v.number(),\n})\n  .index("by_user", ["userId"])\n  .index("by_user_unread", ["userId", "read"])\n  .index("by_created", ["createdAt"]);\n\n\n\nexport default defineSchema({\n  conversations: conversationsTable,\n  conversationParticipants: conversationParticipantsTable,\n  conversationTokenUsage: conversationTokenUsageTable,\n  messages: messagesTable,\n  attachments: attachmentsTable,\n  toolCalls: toolCallsTable,\n  sourceMetadata: sourceMetadataTable,\n  sources: sourcesTable,\n  memories: memoriesTable,\n  files: filesTable,\n  fileChunks: fileChunksTable,\n  knowledgeSources: knowledgeSourcesTable,\n  knowledgeChunks: knowledgeChunksTable,\n  projects: projectsTable,\n  projectConversations: projectConversationsTable,\n  projectNotes: projectNotesTable,\n  projectFiles: projectFilesTable,\n  tasks: tasksTable,\n  notes: notesTable,\n  bookmarks: bookmarksTable,\n  snippets: snippetsTable,\n  tags: tagsTable,\n  bookmarkTags: bookmarkTagsTable,\n  snippetTags: snippetTagsTable,\n  noteTags: noteTagsTable,\n  taskTags: taskTagsTable,\n  shares: sharesTable,\n  scheduledPrompts: scheduledPromptsTable,\n  usageRecords: usageRecordsTable,\n  ttsCache: ttsCacheTable,\n  templates: templatesTable,\n  votes: votesTable,\n  presentations: presentationsTable,\n  slides: slidesTable,\n  outlineItems: outlineItemsTable,\n  designTemplates: designTemplatesTable,\n  presentationSessions: presentationSessionsTable,\n  activityEvents: activityEventsTable,\n  canvasDocuments: canvasDocumentsTable,\n  canvasHistory: canvasHistoryTable,\n  notifications: notificationsTable,\n});\n';
