#!/usr/bin/env bun
/**
 * Automated BYOD schema sync
 *
 * Triggered by pre-commit hook when BYOD schema files change.
 * 1. Detects if schema-affecting files changed
 * 2. Increments BYOD_SCHEMA_VERSION
 * 3. Regenerates packages/byod-schema/
 * 4. Stages all changes (hook's stage_fixed handles this)
 */
import { execFileSync } from "node:child_process";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, "..");

// Files that trigger schema regeneration
const SCHEMA_TRIGGER_FILES = [
  "apps/web/src/lib/byod/schemaGenerator.ts",
  "apps/web/src/lib/byod/downloadProject.ts",
  "apps/web/src/lib/byod/router.ts",
  "apps/web/src/lib/byod/version.ts",
];
const SCHEMA_TRIGGER_DIRS = ["apps/web/src/lib/byod/schema/"];

// Check if any trigger files are staged
function getStagedFiles(): string[] {
  try {
    const output = execFileSync("git", ["diff", "--cached", "--name-only"], {
      encoding: "utf-8",
      cwd: ROOT,
    });
    return output.split("\n").filter(Boolean);
  } catch {
    return [];
  }
}

function shouldTriggerSync(stagedFiles: string[]): boolean {
  return stagedFiles.some(
    (file) =>
      SCHEMA_TRIGGER_FILES.includes(file) ||
      SCHEMA_TRIGGER_DIRS.some((dir) => file.startsWith(dir)),
  );
}

// Read and increment version
function incrementVersion(): number {
  const versionPath = join(ROOT, "apps/web/src/lib/byod/version.ts");
  const content = readFileSync(versionPath, "utf-8");

  const match = content.match(/export const BYOD_SCHEMA_VERSION = (\d+);/);
  if (!match) {
    throw new Error("Could not find BYOD_SCHEMA_VERSION in version.ts");
  }

  const currentVersion = Number.parseInt(match[1], 10);
  const newVersion = currentVersion + 1;

  // Update version file
  const newContent = content.replace(
    /export const BYOD_SCHEMA_VERSION = \d+;/,
    `export const BYOD_SCHEMA_VERSION = ${newVersion};`,
  );

  writeFileSync(versionPath, newContent);
  console.log(
    `üì¶ Incremented BYOD_SCHEMA_VERSION: ${currentVersion} ‚Üí ${newVersion}`,
  );

  return newVersion;
}

// Generate schema files
async function generateSchemaFiles(version: number) {
  const OUTPUT_DIR = join(ROOT, "packages/byod-schema");

  // Import the schema generator (bun can run TS directly)
  const schemaGenModule = await import(
    join(ROOT, "apps/web/src/lib/byod/schemaGenerator.ts")
  );

  // The generator uses the version from its import, which is now updated
  // But since we already modified the file, we need to invalidate the cache
  // Bun doesn't cache dynamic imports the same way, so this should work

  // Generate schema content with updated version in header
  let schemaContent = schemaGenModule.generateSchemaFile() as string;
  // Update the version comment in case it was cached
  schemaContent = schemaContent.replace(
    /Auto-generated BYOD schema v\d+/,
    `Auto-generated BYOD schema v${version}`,
  );

  // Generate functions content
  const generatedFunctionsContent = `// BYOD Functions v${version}
// Auto-generated by blah.chat - DO NOT EDIT

import { query } from "./_generated/server";

// Health check - used to verify connection
export const ping = query({
  args: {},
  handler: async () => {
    return { status: "ok", version: ${version}, timestamp: Date.now() };
  },
});

// System info - returns schema version
export const getSystemInfo = query({
  args: {},
  handler: async () => {
    return {
      schemaVersion: ${version},
      provider: "blah.chat",
      type: "byod",
    };
  },
});
`;

  // Ensure directories exist
  mkdirSync(join(OUTPUT_DIR, "convex"), { recursive: true });

  // Write files
  writeFileSync(join(OUTPUT_DIR, "convex/schema.ts"), schemaContent);
  writeFileSync(join(OUTPUT_DIR, "convex/functions.ts"), generatedFunctionsContent);
  writeFileSync(
    join(OUTPUT_DIR, "package.json"),
    JSON.stringify(
      {
        name: "blah-chat-byod-schema",
        version: "1.0.0",
        private: true,
        dependencies: { convex: "^1.17.0" },
      },
      null,
      2,
    ),
  );
  writeFileSync(
    join(OUTPUT_DIR, "convex.json"),
    JSON.stringify({ functions: "convex/" }, null, 2),
  );
  writeFileSync(
    join(OUTPUT_DIR, "tsconfig.json"),
    JSON.stringify(
      {
        compilerOptions: {
          target: "ESNext",
          module: "ESNext",
          moduleResolution: "bundler",
          strict: true,
          skipLibCheck: true,
        },
        include: ["convex/**/*"],
      },
      null,
      2,
    ),
  );

  console.log(`‚úÖ Generated BYOD schema v${version} in packages/byod-schema/`);
}

// Stage generated files
function stageGeneratedFiles() {
  execFileSync("git", ["add", "apps/web/src/lib/byod/version.ts"], {
    cwd: ROOT,
  });
  execFileSync("git", ["add", "packages/byod-schema/"], { cwd: ROOT });
  console.log("üìù Staged version.ts and packages/byod-schema/");
}

// Main
async function main() {
  const stagedFiles = getStagedFiles();

  // Check if version.ts is the ONLY changed file (avoid double-increment)
  const nonVersionChanges = stagedFiles.filter(
    (f) => f !== "apps/web/src/lib/byod/version.ts",
  );
  const hasSchemaChanges = shouldTriggerSync(nonVersionChanges);

  if (!hasSchemaChanges) {
    console.log("‚ÑπÔ∏è  No BYOD schema changes detected, skipping sync");
    process.exit(0);
  }

  console.log("üîÑ BYOD schema changes detected, syncing...");

  // Check if packages/byod-schema exists (first run message)
  const schemaExists = existsSync(
    join(ROOT, "packages/byod-schema/convex/schema.ts"),
  );
  if (!schemaExists) {
    console.log("üìÅ First run: creating packages/byod-schema/");
  }

  // Increment version
  const newVersion = incrementVersion();

  // Generate files
  await generateSchemaFiles(newVersion);

  // Stage files
  stageGeneratedFiles();

  console.log("‚úÖ BYOD schema sync complete!");
}

main().catch((err) => {
  console.error("‚ùå BYOD schema sync failed:", err);
  process.exit(1);
});
